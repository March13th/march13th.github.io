<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="March 13th">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="March 13th&#39;s Blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="March 13th&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>March 13th&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 6.0.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">March 13th's Blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/05/07/3-Using-the-help-system/">
                3 Using the help system
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-05-07</span>
            
            
            
                <span class="category">
                    <a href="/categories/Learn-Windows-PowerShell-in-a-Month-of-Lunches-读书笔记/">Learn Windows PowerShell in a Month of Lunches-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="使用帮助系统"><a href="#使用帮助系统" class="headerlink" title="使用帮助系统"></a>使用帮助系统</h3><h4 id="帮助系统：发现命令的方法"><a href="#帮助系统：发现命令的方法" class="headerlink" title="帮助系统：发现命令的方法"></a>帮助系统：发现命令的方法</h4><p>如果你不愿意花时间去阅读PowerShell的帮助文档，那么你就无法高效使用PowerShell，也很难进一步学习如何使用它，更不用说使用它管理类似Windows或Exchange等产品，最终你无法摆脱使用GUI的方式</p>
<h4 id="可更新的帮助"><a href="#可更新的帮助" class="headerlink" title="可更新的帮助"></a>可更新的帮助</h4><p>PowerShell v3新功能：可更新的帮助（当查看一个命令的帮助时，你可以得到一个自动生成的简易版的帮助，以及如何更新帮助文档的信息）</p>
<p><code>PS C:\&gt; update-help</code></p>
<h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><ul>
<li>get-help、help和man</li>
</ul>
<p>其中，help和man都不是原生的Cmdlet命令，而是对核心Cmdlet命令进行封装后的函数（<strong>help是一个函数</strong>，<strong>man是help的别名</strong>，<strong>help会把输出的信息管道传送给more</strong>）</p>
<h4 id="使用帮助系统查找命令"><a href="#使用帮助系统查找命令" class="headerlink" title="使用帮助系统查找命令"></a>使用帮助系统查找命令</h4><p>Get-Help一个最为重要的参数是-Name，它是位置参数，所以你无需输入-Name，只需提供所需查找的命令名称，支持通配符<strong>（如果只有一个命令匹配，那么会直接返回该命令的帮助内容而不是命令列表）</strong></p>
<p><code>eg：help *log*</code></p>
<p>结果表中有许多关于事件日志的函数，它们都基于“动词-名词”这个命名格式</p>
<p>当发现某个cmdlet可能有用时，使用help进行确认</p>
<h6 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h6><ol>
<li>help不是为了搜索命令，而是搜索帮助文件；但是因为每个cmdlet都有一个帮助文件，所以从结果上基本相同</li>
<li>Get-Command命令可搜索Cmdlet命令（或者它的别名Gcm）</li>
<li>gcm支持通配符，同时也可以<strong>通过-noun指定名词搜索，通过-verb指定动词搜索，通过-type指定命令类型（例如cmdlet）</strong></li>
</ol>
<h4 id="帮助详解"><a href="#帮助详解" class="headerlink" title="帮助详解"></a>帮助详解</h4><h6 id="1-参数集和通用参数"><a href="#1-参数集和通用参数" class="headerlink" title="1. 参数集和通用参数"></a>1. 参数集和通用参数</h6><p>以get-eventlog为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">名称</span><br><span class="line">    Get-EventLog</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">    Gets the events in an event log, or a list of the event logs, on the local computer or remote computers.</span><br><span class="line"> </span><br><span class="line">语法</span><br><span class="line">    Get-EventLog [-LogName] &lt;System.String&gt; [[-InstanceId] &lt;System.Int64[]&gt;] [-After &lt;System.DateTime&gt;] [-AsBaseObject]</span><br><span class="line">     [-Before &lt;System.DateTime&gt;] [-ComputerName &lt;System.String[]&gt;] [-EntryType &#123;Error | Information | FailureAudit | Su</span><br><span class="line">    ccessAudit | Warning&#125;] [-Index &lt;System.Int32[]&gt;] [-Message &lt;System.String&gt;] [-Newest &lt;System.Int32&gt;] [-Source &lt;Syst</span><br><span class="line">    em.String[]&gt;] [-UserName &lt;System.String[]&gt;] [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line">    Get-EventLog [-AsString] [-ComputerName &lt;System.String[]&gt;] [-List] [&lt;CommonParameters&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，此命令在语法部分出现了两次，这表明该命令提供两个不同的参数集，有两种方式使用此命令</li>
<li>只能使用一个参数集中的参数，不能混用，参数之间是互斥的</li>
<li>如果使用两个参数集共用参数，那么shell会选择第一个参数集</li>
</ul>
<h6 id="2-可选和必选参数"><a href="#2-可选和必选参数" class="headerlink" title="2. 可选和必选参数"></a>2. 可选和必选参数</h6><ul>
<li>可选参数：参数名称和参数值都在方括号中[]，eg： [[-InstanceId] &lt;System.Int64[]&gt;]</li>
<li>必选参数：参数名称和参数值不在一个方括号[]中</li>
<li>当选择一个参数时，只需输入足够的参数名称就可以让PowerShell明白你所需的参数是什么，比如你要输入-list，可以输入-li</li>
<li>如果运行命令eg：get-eventlog，但是没用指定必选参数，powershell会提醒的</li>
</ul>
<h6 id="3-位置参数"><a href="#3-位置参数" class="headerlink" title="3. 位置参数"></a>3. 位置参数</h6><ol>
<li>1 <strong>在语法概要中找到位置参数</strong><br>比如get-eventlog的两个参数<br><code>[-LogName] &lt;string&gt; [[-InstanceId] &lt;Int64[]&gt;]...... [-Before &lt;System.DateTime&gt;]</code></li>
</ol>
<ul>
<li>第一个参数是必选参数，同时-LogName被框了起来，让它成为了一个位置参数</li>
<li>第二个参数是可选参数，他的参数名称和参数值位于同一个方括号内，同时-InstanceId也被[]了起来，这让他同时还是一个位置参数</li>
<li>参数-Before虽然参数名称和参数值都在一个[]中，但是-Before没有被[]起来，所以在使用这个参数时，必须输入参数名称</li>
<li>总结：指定参数名称就可以忽略位置，如果部分指定参数名称则位置参数必须处在正确的位置上</li>
<li>最佳建议：开始的时候总是使用参数名</li>
</ul>
<ol>
<li>2 <strong>在详细的帮助文档中找到位置参数</strong></li>
</ol>
<ul>
<li>Help Get-EventLog -full（或者使用-showwindow）</li>
</ul>
<h6 id="4-参数值"><a href="#4-参数值" class="headerlink" title="4. 参数值"></a>4. 参数值</h6><ul>
<li>string：字符串，如果有空格要用引号</li>
<li>Int32或Int64：一个整数类型</li>
<li>DateTime：日期</li>
<li>有些值包含多个[]，eg：[-ComputerName &lt;string[]&gt;]，string[]<br>意味着该参数可以接受数组、集合，或者是一个列表类型的字符串</li>
<li><strong>一个有用的技巧</strong>：（）可以指定命令优先执行，get-content filename可以从文本文件中读取内容</li>
</ul>
<h6 id="5-发现命令实例"><a href="#5-发现命令实例" class="headerlink" title="5. 发现命令实例"></a>5. 发现命令实例</h6><ul>
<li>eg：<code>Help Get-EventLog -example</code></li>
</ul>
<h4 id="访问在线帮助"><a href="#访问在线帮助" class="headerlink" title="访问在线帮助"></a>访问在线帮助</h4><ul>
<li>eg：Help Get-EventLog -online（这里使用-showwindow好一点）</li>
</ul>
<h4 id="练习（抽了几个，方便时候敲一敲）"><a href="#练习（抽了几个，方便时候敲一敲）" class="headerlink" title="练习（抽了几个，方便时候敲一敲）"></a>练习（抽了几个，方便时候敲一敲）</h4><ol>
<li><p>仅Windows：从安全事件（event）日志检索所有的条目可能需要很长时间，你怎么只获取最近的100条记录呢？</p>
<p><code>help Get-Eventlog –parameter Newest</code></p>
</li>
<li><p>仅Windows：是否有办法可以获取一个远程计算机上安装的服务（services）列表？</p>
<p><code>help Get-Service –parameter computername</code></p>
</li>
<li><p>是否有办法可以看到一个远程计算机运行了什么进程（processes）？</p>
<p><code>help Get-Process –parameter computername</code></p>
</li>
<li><p>怎么使用别名和缩写的参数名称来写一条最短的命令，从而能检索出一台名称为Server1的计算机中正在运行的进程列表？</p>
<p><code>ps –c server1</code></p>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/05/07/%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5/">
                博客记录及常用链接
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-05-07</span>
            
            
            
                <span class="category">
                    <a href="/categories/Precious/">Precious</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="常用链接"><a href="#常用链接" class="headerlink" title="常用链接"></a>常用链接</h2><h6 id="powercat-ps1"><a href="#powercat-ps1" class="headerlink" title="powercat.ps1"></a>powercat.ps1</h6><p><a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat/blob/master/powercat.ps1">https://github.com/besimorhino/powercat/blob/master/powercat.ps1</a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1">https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1</a></p>
<h6 id="CrackStation"><a href="#CrackStation" class="headerlink" title="CrackStation:"></a>CrackStation:</h6><p><a target="_blank" rel="noopener" href="https://crackstation.net/">https://crackstation.net/</a></p>
<h6 id="hashID"><a href="#hashID" class="headerlink" title="hashID:"></a>hashID:</h6><p> <a target="_blank" rel="noopener" href="https://psypanda.github.io/hashID/">https://psypanda.github.io/hashID/</a></p>
<h6 id="Sysinternals"><a href="#Sysinternals" class="headerlink" title="Sysinternals:"></a>Sysinternals:</h6><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/">https://docs.microsoft.com/en-us/sysinternals/downloads/</a></p>
<h6 id="Pythonizing-Nmap"><a href="#Pythonizing-Nmap" class="headerlink" title="Pythonizing Nmap::"></a>Pythonizing Nmap::</h6><p><a target="_blank" rel="noopener" href="https://github.com/gh0x0st/pythonizing_nmap">https://github.com/gh0x0st/pythonizing_nmap</a></p>
<h6 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h6><p><a target="_blank" rel="noopener" href="https://www.regular-expressions.info/">https://www.regular-expressions.info/</a></p>
<h6 id="The-GNU-Awk-User’s-Guide"><a href="#The-GNU-Awk-User’s-Guide" class="headerlink" title="The GNU Awk User’s Guide"></a>The GNU Awk User’s Guide</h6><p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/gawk/manual/gawk.html">https://www.gnu.org/software/gawk/manual/gawk.html</a></p>
<h2 id="博客记录（鉴于我经常搜到无脑复制的博客…这里也包括一些问答）"><a href="#博客记录（鉴于我经常搜到无脑复制的博客…这里也包括一些问答）" class="headerlink" title="博客记录（鉴于我经常搜到无脑复制的博客…这里也包括一些问答）"></a>博客记录（鉴于我经常搜到无脑复制的博客…这里也包括一些问答）</h2><h6 id="How-to-sort-lines-by-length-in-Linux"><a href="#How-to-sort-lines-by-length-in-Linux" class="headerlink" title="How to sort lines by length in Linux?"></a>How to sort lines by length in Linux?</h6><p><a target="_blank" rel="noopener" href="https://www.systutorials.com/how-to-sort-lines-by-length-in-linux/">https://www.systutorials.com/how-to-sort-lines-by-length-in-linux/</a></p>
<h6 id="Encrypted-Bind-and-Reverse-Shells-with-Socat-Linux-x2F-Windows-："><a href="#Encrypted-Bind-and-Reverse-Shells-with-Socat-Linux-x2F-Windows-：" class="headerlink" title="Encrypted Bind and Reverse Shells with Socat (Linux&#x2F;Windows)："></a>Encrypted Bind and Reverse Shells with Socat (Linux&#x2F;Windows)：</h6><p><a target="_blank" rel="noopener" href="https://erev0s.com/blog/encrypted-bind-and-reverse-shells-socat/">https://erev0s.com/blog/encrypted-bind-and-reverse-shells-socat/</a></p>
<h6 id="find-print0和xargs-0原理及用法"><a href="#find-print0和xargs-0原理及用法" class="headerlink" title="find-print0和xargs-0原理及用法:"></a>find-print0和xargs-0原理及用法:</h6><p><a target="_blank" rel="noopener" href="https://blog.my591.com/2021/10/11/find-print0%E5%92%8Cxargs-0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95.html">https://blog.my591.com/2021/10/11/find-print0%E5%92%8Cxargs-0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95.html</a></p>
<h6 id="BASICS-OF-WINDOWS-SECURITY"><a href="#BASICS-OF-WINDOWS-SECURITY" class="headerlink" title="BASICS OF WINDOWS SECURITY:"></a>BASICS OF WINDOWS SECURITY:</h6><p> <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ed_2BKn3QR8">https://www.youtube.com/watch?v=Ed_2BKn3QR8</a></p>
<h6 id="浅谈DNS递归解析和迭代解析之间的区别"><a href="#浅谈DNS递归解析和迭代解析之间的区别" class="headerlink" title="浅谈DNS递归解析和迭代解析之间的区别:"></a>浅谈DNS递归解析和迭代解析之间的区别:</h6><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/303612.html">https://www.freebuf.com/articles/network/303612.html</a></p>
<h6 id="How-does-the-attacker-know-what-algorithm-and-salt-to-use-in-a-dictionary-attack"><a href="#How-does-the-attacker-know-what-algorithm-and-salt-to-use-in-a-dictionary-attack" class="headerlink" title="How does the attacker know what algorithm and salt to use in a dictionary attack?:"></a>How does the attacker know what algorithm and salt to use in a dictionary attack?:</h6><p> <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/180535/how-does-the-attacker-know-what-algorithm-and-salt-to-use-in-a-dictionary-attack/180536#180536">https://security.stackexchange.com/questions/180535/how-does-the-attacker-know-what-algorithm-and-salt-to-use-in-a-dictionary-attack/180536#180536</a></p>
<h6 id="Linux-下进程查看命令-ps"><a href="#Linux-下进程查看命令-ps" class="headerlink" title="Linux 下进程查看命令 ps"></a>Linux 下进程查看命令 ps</h6><p><a target="_blank" rel="noopener" href="https://greenlightt.github.io/2017/10/12/linux-ps/">https://greenlightt.github.io/2017/10/12/linux-ps/</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/">
                第十章、认识和学习BASH
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-10</span>
            
            
            
                <span class="category">
                    <a href="/categories/鸟哥的Linux私房菜-读书笔记/">鸟哥的Linux私房菜-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="认识BASH这个Shell"><a href="#认识BASH这个Shell" class="headerlink" title="认识BASH这个Shell"></a>认识BASH这个Shell</h1><h3 id="Bash-shell的功能"><a href="#Bash-shell的功能" class="headerlink" title="Bash shell的功能"></a>Bash shell的功能</h3><ul>
<li><p>命令编修能力（history）</p>
<ul>
<li>只要在命令行按上下键就可以找到之前输入的指令</li>
<li>这些指令记录在哪里呢：~&#x2F;.bash_history，需要注意的是<strong>其中只包含前一次登陆所执行的命令记录，本次登陆执行的指令被暂存到内存中，待到登出系统后，才会被记录到.bash_history中</strong></li>
</ul>
</li>
<li><p>命令及文件补全</p>
</li>
<li><p>命令别名设置（alias）</p>
</li>
<li><p>工作控制（job，fg，bg）</p>
</li>
<li><p>程序化脚本： （shell scripts）</p>
</li>
<li><p>通配符</p>
</li>
</ul>
<h3 id="查询指令是否为Bash-shell-的内置命令：-type"><a href="#查询指令是否为Bash-shell-的内置命令：-type" class="headerlink" title="查询指令是否为Bash shell 的内置命令： type"></a>查询指令是否为Bash shell 的内置命令： type</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> [-tpa] name</span><br><span class="line">选项与参数：</span><br><span class="line">  ：不加任何选项与参数时，<span class="built_in">type</span> 会显示出 name 是外部指令还是 bash 内置指令</span><br><span class="line">-t  ：当加入 -t 参数时，<span class="built_in">type</span> 会将 name 以下面这些字眼显示出他的意义：</span><br><span class="line">    file    ：表示为外部指令；</span><br><span class="line">    <span class="built_in">alias</span>   ：表示该指令为命令别名所设置的名称；</span><br><span class="line">    <span class="built_in">builtin</span> ：表示该指令为 bash 内置的指令功能；</span><br><span class="line">-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 <span class="built_in">alias</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Shell的变量功能"><a href="#Shell的变量功能" class="headerlink" title="Shell的变量功能"></a>Shell的变量功能</h1><h3 id="变量的取用与设置：echo-unset"><a href="#变量的取用与设置：echo-unset" class="headerlink" title="变量的取用与设置：echo, unset"></a>变量的取用与设置：echo, unset</h3><pre><code>1. 在变量的设置当中，单引号与双引号的用途有何不同？

答：单引号与双引号的最大不同在于双引号仍然可以保有变量的内容，但单引号内仅能是一般字符，而不会有特殊符号。
2. 反单引号的作用
</code></pre>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld `locate crontab`比起这种记法，**鸟哥更建议这种**<span class="built_in">ls</span> -ld $(locate crontab)</span><br></pre></td></tr></table></figure>



<h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><ul>
<li>用env 观察环境变量</li>
<li>用set 观察所有变量（含环境变量与自订变量）</li>
<li>$：（关于本shell 的PID）</li>
<li>?：（关于上个执行指令的回传值，<strong>成功执行则回传一个0值，失败则是非0值</strong>）</li>
<li>export： 自订变量转成环境变量（因为子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量）</li>
</ul>
<h3 id="影响显示结果的语系变量（locale）"><a href="#影响显示结果的语系变量（locale）" class="headerlink" title="影响显示结果的语系变量（locale）"></a>影响显示结果的语系变量（locale）</h3><ul>
<li><p>整体系统默认的语系定义在&#x2F;etc&#x2F;locale.conf </p>
</li>
<li><p>declare &#x2F; typeset（declare 或typeset 是一样的功能，就是在“宣告变量的类型”。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aixr] variable</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型</span><br><span class="line">-i  ：将后面名为 variable 的变量定义成为整数数字 （<span class="built_in">integer</span>） 类型</span><br><span class="line">-x  ：用法与 <span class="built_in">export</span> 一样，就是将后面的 variable 变成环境变量；</span><br><span class="line">-r  ：将变量设置成为 <span class="built_in">readonly</span> 类型，该变量不可被更改内容，也不能 <span class="built_in">unset</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bash对于变量的几个基本定义</p>
<ul>
<li>变量类型默认为“字符串”</li>
<li>bash 环境中的数值运算，默认最多仅能到达整数形态，</li>
<li>阵列（array） 变量类型（var[index]&#x3D;content）</li>
<li><strong>鸟哥建议${变量} or ${阵列}这样读取</strong></li>
</ul>
</li>
</ul>
<h3 id="与文件系统及程序的限制关系：-ulimit"><a href="#与文件系统及程序的限制关系：-ulimit" class="headerlink" title="与文件系统及程序的限制关系： ulimit"></a>与文件系统及程序的限制关系： ulimit</h3><ul>
<li><p>ulimit可以限制使用者的某些系统资源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> [-SHacdfltu] [配额]</span><br><span class="line">选项与参数：</span><br><span class="line">-H  ：hard <span class="built_in">limit</span> ，严格的设置，必定不能超过这个设置的数值；</span><br><span class="line">-S  ：soft <span class="built_in">limit</span> ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。</span><br><span class="line">      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard</span><br><span class="line">      设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，</span><br><span class="line">      系统会有警告讯息通知你！</span><br><span class="line">-a  ：后面不接任何选项与参数，可列出所有的限制额度；</span><br><span class="line">-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），</span><br><span class="line">      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。</span><br><span class="line">-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes</span><br><span class="line">-d  ：程序可使用的最大断裂内存（segment）容量；</span><br><span class="line">-l  ：可用于锁定 （lock） 的内存量</span><br><span class="line">-t  ：可使用的最大 CPU 时间 （单位为秒）</span><br><span class="line">-u  ：单一使用者可以使用的最大程序（process）数量。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>举个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~$ <span class="built_in">ulimit</span> -f 10240</span><br><span class="line"></span><br><span class="line">kali@kali:~$ <span class="built_in">ulimit</span> -a|grep <span class="string">&quot;file size&quot;</span></span><br><span class="line">-f: file size (blocks)              10240</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line"></span><br><span class="line">kali@kali:~$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=testfile bs=1M count=20</span><br><span class="line">zsh: file size <span class="built_in">limit</span> exceeded  <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=testfile bs=1M count=20</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="变量内容的删除、取代与替换（Optional）"><a href="#变量内容的删除、取代与替换（Optional）" class="headerlink" title="变量内容的删除、取代与替换（Optional）"></a>变量内容的删除、取代与替换（Optional）</h3><ul>
<li>变量内容的删除与取代</li>
</ul>
<table>
<thead>
<tr>
<th>变量设置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$&#123;变量#关键字&#125;</code> <code>$&#123;变量##关键字&#125;</code></td>
<td>若变量内容从头开始的数据符合“关键字”，则将符合的最短数据删除若变量内容从头开始的数据符合“关键字”，则将符合的最长数据删除</td>
</tr>
<tr>
<td><code>$&#123;变量%关键字&#125;</code> <code>$&#123;变量%%关键字&#125;</code></td>
<td>若变量内容从尾向前的数据符合“关键字”，则将符合的最短数据删除若变量内容从尾向前的数据符合“关键字”，则将符合的最长数据删除</td>
</tr>
<tr>
<td><code>$&#123;变量/旧字串/新字串&#125;</code> <code>$&#123;变量//旧字串/新字串&#125;</code></td>
<td>若变量内容符合“旧字串”则“第一个旧字串会被新字串取代” 若变量内容符合“旧字串”则“全部的旧字串会被新字串取代”</td>
</tr>
</tbody></table>
<ul>
<li>变量的测试与内容替换</li>
</ul>
<table>
<thead>
<tr>
<th>变量设置方式</th>
<th>str 没有设置</th>
<th>str 为空字串</th>
<th>str 已设置非为空字串</th>
</tr>
</thead>
<tbody><tr>
<td>var&#x3D;${str-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str:+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str&#x3D;expr}</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str 不变var&#x3D;</td>
<td>str 不变var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:&#x3D;expr}</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str 不变var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str?expr}</td>
<td>expr 输出至stderr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:?expr}</td>
<td>expr 输出至stderr</td>
<td>expr 输出至stderr</td>
<td>var&#x3D;$str</td>
</tr>
</tbody></table>
<hr>
<h1 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h1><h3 id="命令别名设置：-alias-unalias"><a href="#命令别名设置：-alias-unalias" class="headerlink" title="命令别名设置： alias, unalias"></a>命令别名设置： alias, unalias</h3><h3 id="历史命令：history"><a href="#历史命令：history" class="headerlink" title="历史命令：history"></a>历史命令：history</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">n   ：数字，意思是“要列出最近的 n 笔命令列表”的意思！</span><br><span class="line">-c  ：将目前的 shell 中的所有 <span class="built_in">history</span> 内容全部消除</span><br><span class="line">-a  ：将目前新增的 <span class="built_in">history</span> 指令新增入 histfiles 中，若没有加 histfiles ，</span><br><span class="line">      则默认写入 ~/.bash_history</span><br><span class="line">-r  ：将 histfiles 的内容读到目前这个 shell 的 <span class="built_in">history</span> 记忆中；</span><br><span class="line">-w  ：将目前的 <span class="built_in">history</span> 记忆内容写入 histfiles 中！</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Bash-Shell-的操作环境"><a href="#Bash-Shell-的操作环境" class="headerlink" title="Bash Shell 的操作环境"></a>Bash Shell 的操作环境</h1><h3 id="路径与指令搜寻顺序"><a href="#路径与指令搜寻顺序" class="headerlink" title="路径与指令搜寻顺序"></a>路径与指令搜寻顺序</h3><ul>
<li>以相对&#x2F;绝对路径执行指令;</li>
<li>由alias 找到该指令来执行；</li>
<li>由bash 内置的（builtin） 指令来执行；</li>
<li>通过$PATH 这个变量的顺序搜寻到的第一个指令来执行。</li>
<li><strong>可以使用type -a查看指令执行的顺序</strong></li>
</ul>
<h3 id="bash-的进站与欢迎讯息"><a href="#bash-的进站与欢迎讯息" class="headerlink" title="bash 的进站与欢迎讯息"></a>bash 的进站与欢迎讯息</h3><ul>
<li>&#x2F;etc&#x2F;issue</li>
<li>&#x2F;etc&#x2F;motd</li>
</ul>
<h3 id="bash-的环境配置文件"><a href="#bash-的环境配置文件" class="headerlink" title="bash 的环境配置文件"></a>bash 的环境配置文件</h3><ul>
<li><p>login 与non-login shell</p>
<ul>
<li>login shell：例如从tty1-tty6登录，需要输入账号密码得到的bash</li>
<li>non-login shell：取得bash接口的方法不需要重复登录的举动，比如直接在图形接口打开bash，或者直接在原本的bash环境下再次bash</li>
</ul>
</li>
<li><p>login shell读取的配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;profile：系统整体的设置</li>
<li><del>&#x2F;.bash_profile或</del>&#x2F;.bash_login或~&#x2F;.profile：使用者个人设置</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;profile（login shell 才会读）</p>
<ul>
<li>可以cat一下这个配置，里面利用uid来决定了一些重要的变量数据，例如PATH等，<strong>并且他还会调用外部的设置数据，比如下面的&#x2F;etc&#x2F;profile.d&#x2F;*.sh</strong></li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;profile.d&#x2F;*.sh【这里包括了bash 操作接口的颜色、 语系、ll 与ls 指令的命令别名、vi 的命令别名、which 的命令别名等等，<strong>但可能因为我是kali的缘故，所以是有一些不同的</strong>，<strong>但是如果再下面创建.sh文件，那么在你发生login shell时，是会读取执行的</strong>】</p>
</li>
<li><p>&#x2F;etc&#x2F;locale.conf【kali没有这个配置】</p>
</li>
<li><p>&#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;completions&#x2F;*【这里是有的】</p>
<ul>
<li>因为这个文件，我们才体会到【tab】的文件名补齐、命令补齐的妙用，就是从这个目录找到相应的指令处理的，<strong>这个目录下的内容是由&#x2F;etc&#x2F;profile.d&#x2F;bash_completion.sh 文件载入的</strong></li>
</ul>
</li>
<li><p>~&#x2F;.bash_profile （login shell 才会读）</p>
<ul>
<li>bash读取&#x2F;etc&#x2F;profile并调用其他配置文件后，然后读取使用者个人配置文件，依次是【这是有顺序的，如果.bash_profile存在，就不读取后面的文件】<ul>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bash_login</li>
<li>~&#x2F;.profile</li>
</ul>
</li>
</ul>
</li>
<li><p>整个login shell的读取流程</p>
<p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410193627069.png" alt="image-20220410193627069"></p>
</li>
<li><p>source ：读入环境配置文件的指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrcA <span class="comment">#将 ~/.bashrc 的设置读入目前的 bash 环境中，也可以使用.</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>~&#x2F;.bashrc （non-login shell 会读，仅仅会读取这个文件，CentOs会读取&#x2F;etc&#x2F;bashrc，但者是根据不同的distributions来决定的）</p>
</li>
<li><p>其他相关配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;man_db.conf【规定了man的时候，该去哪里查看数据的路径设置】</li>
<li>~&#x2F;.bash_history【历史命令】</li>
<li>~&#x2F;.bash_logout【当我登出bash后，系统帮我做什么可以在这里定义】</li>
</ul>
</li>
</ul>
<h3 id="终端机的环境设置：-stty-set"><a href="#终端机的环境设置：-stty-set" class="headerlink" title="终端机的环境设置： stty, set"></a>终端机的环境设置： stty, set</h3><ul>
<li><p>stty（setting tty，帮助设置终端的输入按键代表意义）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stty</span> [-a]</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：将目前所有的 <span class="built_in">stty</span> 参数列出来；</span><br><span class="line"></span><br><span class="line"><span class="comment">#intr : 送出一个interrupt （中断） 的讯号给目前正在run 的程序（就是终止啰！）；</span></span><br><span class="line"><span class="comment">#quit : 送出一个quit 的讯号给目前正在run 的程序；</span></span><br><span class="line"><span class="comment">#erase : 向后删除字符，</span></span><br><span class="line"><span class="comment">#kill : 删除在目前命令行上的所有文字；</span></span><br><span class="line"><span class="comment">#eof : End of file 的意思，代表“结束输入”。</span></span><br><span class="line"><span class="comment">#start : 在某个程序停止后，重新启动他的output</span></span><br><span class="line"><span class="comment">#stop : 停止目前屏幕的输出；</span></span><br><span class="line"><span class="comment">#susp : 送出一个terminal stop 的讯号给正在run 的程序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你想修改的话，可以这样设置</span></span><br><span class="line"><span class="built_in">stty</span> erase ^h</span><br></pre></td></tr></table></figure>


</li>
<li><p>set（可以帮我们设置整个指令输出&#x2F;输入的环境）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> [-uvCHhmBx]</span><br><span class="line">选项与参数：</span><br><span class="line">-u  ：默认不启用。若启用后，当使用未设置变量时，会显示错误讯息；</span><br><span class="line">-v  ：默认不启用。若启用后，在讯息被输出前，会先显示讯息的原始内容；</span><br><span class="line">-x  ：默认不启用。若启用后，在指令被执行前，会显示指令内容（前面有 ++ 符号）</span><br><span class="line">-h  ：默认启用。与历史命令有关；</span><br><span class="line">-H  ：默认启用。与历史命令有关；</span><br><span class="line">-m  ：默认启用。与工作管理有关；</span><br><span class="line">-B  ：默认启用。与刮号 [] 的作用有关；</span><br><span class="line">-C  ：默认不启用。若使用 &amp;gt; 等，则若文件存在时，该文件不会被覆盖。</span><br><span class="line"></span><br><span class="line">显示目前所有<span class="built_in">set</span>设置值</span><br><span class="line"><span class="built_in">echo</span> $-（默认himBH）<span class="comment">#这里注意是bash的默认值，kali默认是zsh，会显示的很奇怪</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>鸟哥不建议修改tty的设置，只是希望我们知道终端是如何设置的</strong></p>
</li>
<li><p>bash默认组合键</p>
<p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410224525785.png" alt="image-20220410224525785"></p>
</li>
</ul>
<h3 id="万用字符与特殊符号"><a href="#万用字符与特殊符号" class="headerlink" title="万用字符与特殊符号"></a>万用字符与特殊符号</h3><p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410224609447.png" alt="image-20220410224609447"></p>
<p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410225214834.png" alt="image-20220410225214834"></p>
<h1 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h1><h3 id="什么是数据流重导向"><a href="#什么是数据流重导向" class="headerlink" title="什么是数据流重导向"></a>什么是数据流重导向</h3><p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410225329822.png" alt="image-20220410225329822"></p>
<h3 id="命令执行的判断依据：-amp-amp"><a href="#命令执行的判断依据：-amp-amp" class="headerlink" title="命令执行的判断依据： ; , &amp;&amp;, ||"></a>命令执行的判断依据： ; , &amp;&amp;, ||</h3><p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410225408162.png" alt="image-20220410225408162"></p>
<p><img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410225428812.png" alt="image-20220410225428812"></p>
<ul>
<li>一般来说都是这样子的，<code>command1 &amp;&amp; command2 || command3</code>，而且顺序通常不会变， command2 与command3 会放置肯定可以执行成功的指令</li>
</ul>
<h1 id="管线命令（pipe）"><a href="#管线命令（pipe）" class="headerlink" title="管线命令（pipe）"></a>管线命令（pipe）</h1><ul>
<li>管线命令处理示意图</li>
</ul>
<p>​    <img src="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/image-20220410225636383.png" alt="image-20220410225636383"></p>
<ul>
<li>几个命令： <strong>cut</strong>，grep，<strong>sort</strong>， wc， <strong>uniq</strong>，tee，tr，col，join， paste，expand，split，<strong>xargs</strong><ul>
<li>感觉这里用的比较多的就是上面加黑的，用多了就好了；感觉split挺有意思</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>关于减号- 的用途（某些指令需要用到文件名称（例如tar） 来进行处理时，该stdin 与stdout 可以利用减号”-“ 来替代）</p>
<ul>
<li><p>这个在使用nc传文件时也可以得到体现，eg：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lp 12345|tar -xvf -    <span class="comment">#A机</span></span><br><span class="line">tar -cvf - payload|nc localhost 12345   <span class="comment">#B机</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/">
                关于SSH指纹的一点记录
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-31</span>
            
            
            
                <span class="category">
                    <a href="/categories/Triffle/">Triffle</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>最近在学习SSH的时候，我有个困惑，下面的这个界面，出现了无数次，但是从没认真了解过，小记一下</p>
<p><img src="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/image-20220331222254321-16487365808101.png" alt="image-20220331222254321"></p>
<p>为啥要给我看这么个指纹，这个指纹又是什么。</p>
<p>首先</p>
<h3 id="什么是指纹"><a href="#什么是指纹" class="headerlink" title="什么是指纹"></a>什么是指纹</h3><p>指纹是根据公钥信息生成的，简短的想证明<strong>”他是他“</strong>的东西</p>
<h3 id="怎么知道他是根据公钥生成的呢"><a href="#怎么知道他是根据公钥生成的呢" class="headerlink" title="怎么知道他是根据公钥生成的呢"></a>怎么知道他是根据公钥生成的呢</h3><p>注意上面图片的指纹信息了么，他是这样的（以下使用都是ssh到本机进行模拟）</p>
<p><img src="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/image-20220331223101569-16487370632612.png" alt="image-20220331223101569"></p>
<p>那么现在让我们生成一下他</p>
<p><img src="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/image-20220331223200394-16487371217923.png" alt="image-20220331223200394"></p>
<p>不觉得熟悉么，这不是一摸一样么，现在再来看看我们在进行ssh连接时保存下来的公钥信息和服务端本身的公钥信息（存在$HOME&#x2F;.ssh&#x2F;known_hosts，下次登录发现这里有就不会警告了）</p>
<p><img src="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/image-20220331223649261-16487374103744.png" alt="image-20220331223649261"></p>
<p>实际上就是把公钥发来了，然后就是用户用公钥加密账号密码，服务端再私钥解密，密码正确–&gt;同意登录，扯远了，继续说指纹的事，用ssh-keyscan再多次一举一下</p>
<p><img src="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/image-20220331225023418-16487382247505.png" alt="image-20220331225023418"></p>
<p>看，还是他。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/">
                TCP连接与断开小记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Triffle/">Triffle</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/v2-cf4e7d7b386df75a8cde40d2e0e1e6b2_r-16478665349409.jpg" alt="TCP/IP详解卷1"></p>
<p>​    最近恰巧有朋友问过我三次握手四次挥手，顺便记录一下，可惜我也是一知半解。</p>
<p>​    首先，TCP连接就是为了在不可靠的信道上建立可靠的连接</p>
<h3 id="为什么不采用两次握手建立连接呢"><a href="#为什么不采用两次握手建立连接呢" class="headerlink" title="为什么不采用两次握手建立连接呢"></a>为什么不采用两次握手建立连接呢</h3><p>​    因为说了TCP是为了建立<strong>可靠</strong>的连接，这意味着<strong>完整、有序</strong>，TCP是个双向通信协议，通信双方都要判断发送的数据包是否被接收方收到，所以才有<strong>序号</strong>和<strong>确认号</strong></p>
<p>​    所以…让我举个栗子</p>
<pre><code>1. A对B说，我要连你！我发的信息从序号123（SYN seq=123）开始
1. B对A说，**收到你信息拉**，可以给我发这个序号的信息（ACK ack=124），对了！我发的信息从序号456（SYN seq=456）开始
1. A对B说，**知道拉**，那你可以给我发序号457（ACK ack=457）的信息
</code></pre>
<p>​    上面是想说什么呢，TCP是个双向通信协议，如果想要相互确认初始序列号 ( Initial Sequence Number, ISN )，需要三次，如果只有两次的话，对于B来说，他是得不到确认的，不懂就试试。</p>
<h3 id="试试就知道"><a href="#试试就知道" class="headerlink" title="试试就知道"></a>试试就知道</h3><p>​    Wireshark捕获Loopback，nc一头监听一头连接</p>
<p>​    <code>nc -lp 1234</code></p>
<p>​    <code>nc 127.0.0.1 1234</code></p>
<p>​    <img src="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/image-20220321224509825.png" alt="image-20220321224509825"></p>
<p><img src="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/image-20220321224934194.png" alt="image-20220321224934194"></p>
<p><img src="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/image-20220321225206805.png" alt="image-20220321225206805"></p>
<p><strong>上面的最后一包ACK之后，客户端的下一包报文Seq是多少？？？</strong></p>
<p>因为SYN报文段不能携带数据，但是要消耗一个序列号；ACK报文段可以携带数据，但是如果不携带数据就不消耗序列号，下一个报文段的序号仍然是Seq&#x3D;ISN(c)+1</p>
<p><strong>那么为啥SYN包要消耗一个序列号呢</strong></p>
<p>因为要ack这个syn（fin），而不ack对方的ack</p>
<h3 id="至于四次挥手…我决定偷个懒，来个一图胜千言（图片来自YouTube）"><a href="#至于四次挥手…我决定偷个懒，来个一图胜千言（图片来自YouTube）" class="headerlink" title="至于四次挥手…我决定偷个懒，来个一图胜千言（图片来自YouTube）"></a>至于四次挥手…我决定偷个懒，来个一图胜千言（图片来自YouTube）</h3><p><img src="/2022/03/21/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E5%B0%8F%E8%AE%B0/image-20220321233351983.png" alt="image-20220321233351983"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/20/Section-1-Networking-Concepts/">
                Section 1 Networking Concepts(Professor Messer’s CompTIA N10-008 Network+ Course)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/Professor-Messer’s-CompTIA-N10-008-Network-Course-notes/">Professor Messer’s CompTIA N10-008 Network+ Course(notes)</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="1-1-–-The-OSI-Model"><a href="#1-1-–-The-OSI-Model" class="headerlink" title="1.1 – The OSI Model"></a>1.1 – The OSI Model</h3><h4 id="Understanding-the-OSI-Model"><a href="#Understanding-the-OSI-Model" class="headerlink" title="Understanding the OSI Model"></a>Understanding the OSI Model</h4><ul>
<li><p>记住OSI模型的一种方法：All People Seem To Need Data Processing</p>
<p>[application, presentation, session, transport, network, data link, and physical.]</p>
<p>Layer1:<strong>The physics of the network</strong>[eg:cables…]</p>
<p>Layer2:<strong>The data link layer</strong></p>
<ul>
<li><p>The foundational layer for the protocols</p>
</li>
<li><p>Data Link Control(DLC) protocols<br>[MAC address an Ethernet]</p>
</li>
<li><p>The “switching” layer[ Since switches make their forwarding decisions based on these MAC addresses, we sometimes will refer to Layer 2 as the “switching” layer.]</p>
</li>
</ul>
<p>Layer3:<strong>The network layer</strong>[Internet Protocol (IP)、Router]<br>Layer4:<strong>The Transport layer</strong>[TCP and UDP]<br>Layer5:<strong>The Session layer</strong></p>
<ul>
<li>Communication management between devices</li>
</ul>
<p>Layer6:<strong>The Presentation layer</strong></p>
<ul>
<li>character encoding</li>
<li>application encryption</li>
<li>often combined with application layer<br>Layer7:<strong>The Applicationlayer</strong>[HTTP&#x2F;DNS&#x2F;FTP&#x2F;POP3]</li>
<li>the layer we see</li>
</ul>
</li>
<li><p>之前都没有注意过wireshark中实际也是分层显示的</p>
</li>
</ul>
<h4 id="Data-Communication"><a href="#Data-Communication" class="headerlink" title="Data Communication"></a>Data Communication</h4><p><img src="/2022/03/20/Section-1-Networking-Concepts/1240.png" alt="data communication 1"></p>
<p><img src="/2022/03/20/Section-1-Networking-Concepts/1240-16477712310491.png" alt="data communication 2"></p>
<ul>
<li><p>The header describes or identifies the payload</p>
</li>
<li><p>The TCP header contains important control information</p>
<ul>
<li>Includes a set of bits called TCP flags</li>
</ul>
</li>
<li><p>The flags control the payload</p>
<ul>
<li><p>SYN:synchronize sequence numbers</p>
</li>
<li><p>RST:reset the connection</p>
</li>
<li><p>FIN:last packer from the sender</p>
<p><img src="/2022/03/20/Section-1-Networking-Concepts/1240-16477712310492.png" alt="flags"></p>
</li>
</ul>
</li>
<li><p>Maximum Transmission Unit(MTU)</p>
<ul>
<li><p>这指定了我们能够通过网络发送的数据大小，而无需进一步分割任何信息</p>
</li>
<li><p>如果我想发一个44字节的数据，但是MTU&#x3D;16，那么我不得不分为3帧来发</p>
</li>
<li><p>可以使用ping进行试验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -f -l 1472 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>[为什么是1472，the ping command is specifying that 1,500 bytes minus the ICMP header of 8 bytes, and minus the 20-byte header of the IP address itself, leaving us with 1,472]</p>
<p>我这里因为环境中有vpn，报文在传输过程中有额外的封装</p>
<p><img src="/2022/03/20/Section-1-Networking-Concepts/1240-16477712310493.png" alt="troubleshoot using ping"></p>
</li>
</ul>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/">
                第八章、文件与文件系统的压缩与打包
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/鸟哥的Linux私房菜-读书笔记/">鸟哥的Linux私房菜-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>认识Linux文件系统</p>
<ul>
<li>Linux中常见的压缩命令：zip，gzip（zcat），bzip2（bzcat），其中后两个共同的选项（-d：解压缩；-c 保留源文件压缩）</li>
<li>打包命令：tar</li>
<li>备份<ul>
<li>dump</li>
<li>dd：dd if&#x3D;&#x2F;dev&#x2F;sda3 of&#x3D;test 即可</li>
<li>cpio：压缩：find .&#x2F;Try -name ‘host*’ | cpio -o &gt; xx.cpio,解压缩：cpio -iu &lt; xx.cpio</li>
</ul>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">
                第七章、Linux磁盘与文件系统管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/鸟哥的Linux私房菜-读书笔记/">鸟哥的Linux私房菜-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <ul>
<li>认识Linux文件系统<ul>
<li>磁盘组成及分区复习(正好给自己提几个问题)<ul>
<li>什么是扇区，有哪两种格式<ul>
<li>扇区(Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512bytes 与 4K 两种格式；</li>
</ul>
</li>
<li>什么是磁柱<ul>
<li>将扇区组成一个圆，那就是磁柱(Cylinder)；</li>
</ul>
</li>
<li>磁盘分区表的两种格式<ul>
<li>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</li>
</ul>
</li>
<li>MBR第一个扇区由什么组成呢<ul>
<li>MBR 分区表中，第一个扇区最重要，里面有： (1)主要开机区(Master boot record, MBR)及分区表(partition<br>table)， 其中 MBR 占有 446 bytes，而 partition table 则占有 64 bytes。</li>
</ul>
</li>
<li>实体磁盘的文件名是什么<ul>
<li>&#x2F;dev&#x2F;sd[a-p][1-128]</li>
</ul>
</li>
<li>虚拟磁盘的文件名是什么<ul>
<li>&#x2F;dev&#x2F;vd[a-d][1-128]</li>
</ul>
</li>
</ul>
</li>
<li>文件系统特性<ul>
<li><strong>什么是格式化</strong>，(我以前只是觉得是清空哈哈哈哈，还真没想过)，每种操作系统所设定的文件属性和权限并不相同，格式化分区槽是为了让它变成系统能够使用的”文件系统格式”</li>
<li><strong>文件系统</strong>通常将权限和属性放到inode中，实际数据放到data block区块中，另外有一个超级区块(superblock)会记录整个文件系统的整体信息(inode与block的总量呀，使用量呀，剩下多少呀，听起来像一个管家哈哈哈哈)</li>
<li><strong>inode、block、superblock的简要概述</strong><ul>
<li>superblock：记录此 filesystem 的整体信息(inode&#x2F;block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息)</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录文件数据所在的block号码</li>
<li>block：实际记录文件的内容，如果是很大的文件就多占一些block啦</li>
</ul>
</li>
<li><strong>关于碎片整理</strong><ul>
<li>需要碎片整理是因为写入的block过于离散啦，想想磁盘机械手臂的磁盘读取头来来回回的我都觉得累，碎片整理就是将同一个文件的block整理到一起，那么数据的读取就变得容易，但是Ext2是<strong>索引式文件系统</strong>(一下子将inode中的block号码对应的block全读出来，是不是有点像散列表哈哈哈)，不太需要碎片整理啦，但是如果是以前的老式u盘呢，例如FAT格式(这里读取block是需要一个一个读取的，感觉像链表)，就需要碎片整理了</li>
</ul>
</li>
</ul>
</li>
<li>Linux的Ext2文件系统(inode)</li>
</ul>
<ul>
<li>文件系统一开始就将inode与block规划好了，除非重新格式化or利用resize2fs等指令变更文件系统大小，否则inode和block就固定不再变动啦<ul>
<li>关于区块群组<ul>
<li>如果文件系统太大啦，那么那么夺得inode与block都放在一起也不好管理，于是Ext2文件系统在格式化的时候会区分为多个区块群组，而每个群组都有独立的inode、block、superblock系统<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240.png"></li>
<li>接上图，文件系统最前面有一个启动扇区(boot sector)可安装开机管理程序，所以我们才能由多重引导呀！</li>
</ul>
</li>
<li>data block<ul>
<li>Ext2 文件系统中所支持的 block 大小有 1K, 2K 及<br>4K 三种而已<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240-1647257365181100.png"></li>
<li>上图非绝对，某些应用程序捕捉不到辣么大的文件</li>
<li>关于<strong>Ext2文件系统block的限制</strong><ol>
<li>原则上， block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)</li>
<li>每个 block 内最多只能够放置一个文件的数据</li>
<li>如果文件大于 block 的大小，则一个文件会占用多个 block 数量</li>
<li>若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)</li>
<li>现在磁盘都太大啦，4k就好，知道原理就行</li>
</ol>
</li>
</ul>
</li>
<li>inode table<ul>
<li><strong>inode记录的文件数据</strong>至少有：<ol>
<li>该文件的存取模式(read&#x2F;write&#x2F;excute)；</li>
<li>该文件的拥有者与群组(owner&#x2F;group)；</li>
<li>该文件的容量；</li>
<li>该文件建立或状态改变的时间(ctime)；</li>
<li>最近一次的读取时间(atime)；</li>
<li>最近修改的时间(mtime)；</li>
<li>定义文件特性(flag)，如 SetUID…；</li>
<li>该文件真正内容的指向 (pointer)；</li>
</ol>
</li>
<li><strong>关于inode的特色</strong><ol>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)</li>
<li>每个文件都仅会占用一个inode</li>
<li>文件系统能够建立的文件数量与inode的数量有关</li>
<li>系统读取文件需先找到inode，先分析inode所记录的权限与用户是否符合，如果符合才能够开始读取block内容</li>
</ol>
</li>
<li><strong>关于inode的12个直接、一个间接、一个双间接和一个三间接</strong><ul>
<li>如果文件很大呢，inode记录一个block号码要花费4byte，根本记录不下那么多block号码<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240-1647257368613102.png"></li>
<li>直接就是直接指向block号码的对照</li>
<li>间接就是再拿一个block当作记录block号码的记录区</li>
<li>双间接就是使用第一个block来记录block号码</li>
<li>三间接就是使用第二个block记录block号码</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>假如block大小为1k，inode能指定多少block呢<ul>
<li>12个直接：12*1K&#x3D;12K</li>
<li>间接：256*1K&#x3D;256K</li>
<li>双间接：256<em>256</em>1K&#x3D;2562K</li>
<li>三间接： 256<em>256</em>256*1K&#x3D;2563K</li>
<li>总额&#x3D;12 + 256 + 256<em>256 + 256</em>256*256 (K) &#x3D; 16GB</li>
<li>注意2k与4k block不能这么计算，因为会受到Ext2文件系统本身的限制</li>
</ul>
</li>
</ul>
<ul>
<li><p>superblock</p>
<ul>
<li><strong>superblock记录的主要信息</strong><ol>
<li>block与inode的总量</li>
<li>未使用与已使用的inode和block数量</li>
<li>block与inode的大小(block 为 1, 2, 4K， inode 为 128bytes 或 256bytes)</li>
<li>filesystem的挂载时间，最近一次写入数据的时间，最近一次检查磁盘(fsck)的时间等文件系统相关信息</li>
<li>一个valid bit数值，如果这个文件系统已经被挂载，valid bit为0，否则valid bit为1</li>
<li><strong>注意</strong>：除了第一个block group含有superblock之外，后面的block group不一定含有superblock，如果有的话呢，主要是作为第一个block group内superblock的备份，用于救援</li>
</ol>
</li>
<li><strong>Filesystem Description(文件系统描述谁说明)</strong><ol>
<li>该区段描述每个block group的开始和结束block号码，以及每个区段(superblock、bitmap、inodemap、data block)分别介于哪一个block号码之间</li>
</ol>
</li>
</ul>
</li>
<li><p>block bitmap(区块对照表)**</p>
<ul>
<li><strong>block bitmap记录的主要信息</strong><ol>
<li>记录哪些block是空的</li>
<li>再删除某些文件时，文件原本占用的block号码需要释放，block bitmap中相应的block号码标志就会被修改为”空闲”</li>
</ol>
</li>
</ul>
</li>
<li><p>查看文件的inode</p>
<ul>
<li>使用ls -i name查看inode，另外可以使用filefrag -v name查看文件分布在哪些block中</li>
</ul>
</li>
<li><p>dumpe2fs：查询Ext家族superblock信息的指令**</p>
<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. dumpe2fs [-bh] 装置文件名</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-b ：列出保留为坏轨的部分(用不到 )</li>
<li>-h ： 仅列出 superblock 的数据，不会列出其他的区段内容。</li>
</ol>
</li>
<li>blkid:显示目前系统被格式化的装置</li>
<li>dumpe2fs的部分字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">        1. Filesystem volume name：文件系统的名称</span><br><span class="line">        2. Last mounted on：上一次挂载的目录位置</span><br><span class="line">        3. Filesystem UUID：Linux对装置的定义码</span><br><span class="line">        4. Filesystem features：文件系统的特征数据</span><br><span class="line">        5. Default mount options：预设在挂载时会主动加上的挂载参数</span><br><span class="line">        6. Filesystem state：这块系统的文件的状态，clean是没问题的意思</span><br><span class="line">        7. Inode count：inode的总数</span><br><span class="line">        8. Block count：block的总数</span><br><span class="line">        9. Reserved block count：保留的block总数</span><br><span class="line">        10. Free blocks：空闲的block可用数量</span><br><span class="line">        11 Free inodes：空闲的inode可用数量</span><br><span class="line">        12. Block size：单个block的容量大小</span><br><span class="line">        13. inode size：inode的容量大小</span><br><span class="line">        14. Journal size：日志式数据的可供记录总量</span><br><span class="line">        15. Group 0：第一块block group位置</span><br><span class="line">        16. Primary superblock at 0, Group descriptors at 1-1：主要 superblock 的所在</span><br><span class="line">        17. Inode table at 161-672 (+161)：inode table的所在</span><br><span class="line">        18. Free blocks：剩余的容量有多少</span><br><span class="line">  - 与目录树的关系</span><br><span class="line">    + 目录</span><br><span class="line">      * 当我们在linux的文件系统建立一个目录时，系统会分配一个inode和至少一块block给该目录，inode记录该目录的权限、属性and分配到的block号码，block记录在这个目录下的文件名和该文件名占用的inode号数据[要记得这只是个目录呀]</span><br><span class="line">      * 当目录下的文件数过多导致一个block无法容纳所有文件名+inode对照号码时，Linux会给于该目录多一个block来记录相关的数据</span><br><span class="line">    + 文件</span><br><span class="line">      * 当我们在Linux的ext2建立一个一般文件时，ext2分配一个inode与相匹配与文件大小的block给该文件，[记得如果文件很大时候我们还有inode的12个直接、一个间接、一个双间接和一个三间接帮忙]</span><br><span class="line">    + 目录树读取</span><br><span class="line">      * eg：读取/etc/passwd的过程</span><br><span class="line">        1. / 的 inode：</span><br><span class="line">            透过挂载点的信息找到根目录 inode，且 inode 规范的权限让我们可以读取该 block的内容(有 r 与 x)；</span><br><span class="line">        2. / 的 block：</span><br><span class="line">            取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码；</span><br><span class="line">        3. etc/ 的 inode：</span><br><span class="line">            读取 etc的inode号码得知用户具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容；</span><br><span class="line">        4. etc/ 的 block：</span><br><span class="line">            取得 block 号码，并找到该内容有 passwd 文件的 inode 号码；</span><br><span class="line">        5. passwd 的 inode：</span><br><span class="line">            读取passwd的inode号码得知用户具有  r 的权限，因此可以读取 passwd 的 block 内容；</span><br><span class="line">        6. passwd 的 block：</span><br><span class="line">            将该 block 内容的数据读出来。</span><br><span class="line">    + filesystem 大小与磁盘读取效能</span><br><span class="line">      * 文件系统过大可能会有文件数据离散的问题发生，合理规划分区</span><br><span class="line">  - EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能</span><br><span class="line">    + 新增一个文件时文件系统的行为</span><br><span class="line">      1. 确定新增文件的目录是不是有相应权限</span><br><span class="line">      2. 根据inode bitmap找到没有使用的inode号码，将新文件的权限/属性写入</span><br><span class="line">      3. 根据block bitmap找到未使用的block号码，将实际数据写入block，并更新inode的block指向</span><br><span class="line">      4. 将刚刚写入的inode与block数据同步至inode  bitmap与block bitmap，并更新superblock的内容</span><br><span class="line">    + 数据存放区域与中介数据 </span><br><span class="line">      1. 将inode table与data block称为数据存放区域</span><br><span class="line">      2. 将其他eg：superblock、block bitmap与inode bitmap等区段称为metadata(因为superblock、block bitmap与inode bitmap数据经常变动，无论新增、删除还是修改都会影响这几个区段的数据，所以就叫中介数据啦)</span><br><span class="line">    + 数据不一致(inconsistent)状态</span><br><span class="line">      1. 写入inode table与data block数据之后，嘣！停电了！系统不知道为啥断了！metadata的内容与实际数据存放区不一致</span><br><span class="line">      2. Ext2中，如果有此情况，系统重新启动后会由superblock当中的valid bit与filesystem state等状态判断是否强行进行数据一致性检查(费事费力，要针对metadata区域与实际数据存放区进行对比，要搜寻整个filesystem，于是引出了日志式文件系统)</span><br><span class="line">    + 日志式文件系统(journaling filesystem)</span><br><span class="line">      * 简化了的一直性检查的步骤</span><br><span class="line">        1. 预备：当系统要写入一个文件，在日志记录区块中记录某个文件准备要写入的信息</span><br><span class="line">        2. 实际写入：写入文件的权限and数据，更metadata的数据</span><br><span class="line">        3. 结束：完成数据与metadata的更新</span><br><span class="line">      * 这样做的好处在于有问题检查日志记录区块就好了，不用针对整块filesystem检查</span><br><span class="line">    + Linux文件系统的运作</span><br><span class="line">      * 关于异步处理(asynchronously)的方式</span><br><span class="line">        系统加载一个文件到内存后，如果文件没有修改过，那么内存区段的文件数据就会设定为干净(clean)的,但是如果内存中的文件被修改过，此时内存中的数据就会被设定为脏的(dirty)，此时所有的动作都在内存中进行，不写入到磁盘，然后系统不定时的将内存中设定为dirty的数据写回磁盘，以保持磁盘和内存数据一致性</span><br><span class="line">      * 关于Linux文件系统与内存的关系</span><br><span class="line">        1. 系统将常用的文件数据放置到主存储器的缓冲区，用来加速文件系统的读写</span><br><span class="line">        2. 所以Linux的物理内存最后都会被用光，这是正常滴，为了加速系统效能</span><br><span class="line">        3. 可以使用sync来强迫内存中dirty的文件回写到磁盘</span><br><span class="line">        4. 关机指令会主动呼叫sync</span><br><span class="line">        5. 非正常系统中断，由于数据未回写到磁盘，重新启动可能要花费时间进行磁盘检验，还有可能导致文件系统的损毁(不是磁盘坏了...)</span><br><span class="line">    + 挂载点的意义(mount point)</span><br><span class="line">      * 挂载点一定时目录,该目录未进入该文件系统的入口</span><br><span class="line">      * **这里要重点重重点记录一下了!!!**这里我本来一直没搞清楚为什么/，/home，/boot这三个目录的inode的号码都是一样的，而且为什么说/，/home，/boot是三个不同的文件系统</span><br><span class="line">        _**因为他们都挂载在根目录啊，目录是目录，挂载只是挂在树上的果子而已，谁或三个果子不能长在一个枝桠上，剩下的事交给目录inode指向的block，而/，/home，/boot的文件属性并不相同，挂载点也不相同，所以自然是三个不同的文件系统**_</span><br><span class="line">      * 为什么/，/.，/..是一样的东西呢，可以看一看，文件属性相同，还指向一个inode，还都是一个挂载点，当然是一个东西[官方一点说，同一个filesystem的某个inode只会对应到一个文件内容，毕竟一个文件占用一个inode嘛]</span><br><span class="line">  - 其他 Linux 支持的文件系统与 VFS</span><br><span class="line">    + 常见的支持的日志式文件系统</span><br><span class="line">      *  传统文件系统： ext2 / minix / MS-DOS / FAT (用 vfat 模块) / iso9660 (光盘)等等</span><br><span class="line">      *  日志式文件系统： ext3 /ext4 / ReiserFS / Windows&#x27; NTFS / IBM&#x27;s JFS / SGI&#x27;s XFS / ZFS</span><br><span class="line">      *  网络文件系统： NFS / SMBFS</span><br><span class="line">    + 查看Linux支持的文件系统</span><br><span class="line">      ```ls -l /lib/modules/$(uname -r)/kernel/fs```</span><br><span class="line">    + 查看目前已加载到内存中支持的文件系统</span><br><span class="line">      ```cat /proc/filesystems```</span><br><span class="line">    + Linux VFS(virtual filesystem switch)</span><br><span class="line">      * 整个linux系统都是通过名为vfs的核心功能来读取filesystem的，所以我们才无需知道每个partition是什么，vfs主动帮我们做好读取的工作</span><br><span class="line">    + vfs简略图</span><br><span class="line">         ![](1240-1647257373446104.png)</span><br><span class="line">  - XFS 文件系统简介</span><br><span class="line">    + EXT 家族： 支持度最广，格式化超慢</span><br><span class="line">      * ext家族采用的是预先规划处所有的inode/block/metadata等数据，但是目前磁盘容量愈来愈大，传统MBR被GPT取代，格式化的时候预先分配inode和block要耗费大量时间</span><br><span class="line">    + XFS 文件系统的配置</span><br><span class="line">      * xfs主要规划为三个部分，一个资料区 (data section)、一个文件系统活动登录区 (log section)以及一个实时运作区 (realtime section)    </span><br><span class="line">        1. 资料区(data section)</span><br><span class="line">          * 与ext家族一样包括 inode/data block/superblock 等数据</span><br><span class="line">          * 与ext家族类似，data section分为多个储存区群组(allocation groups)，每个储存区群组包含(1)整个文件系</span><br><span class="line">        统的 superblock、 (2)剩余空间的管理机制、 (3)inode 的分配与追踪。</span><br><span class="line">          * inode与block在系统需用时动态生成</span><br><span class="line">          * 与ext家族不同之处，xfs的block与inode哟多种不同的容量可设定，block[512bytes ~ 64K,最高4k，不然linux核心不给挂载没法用]，inode[256bytes ~2M，256bytes的默认值即可]</span><br><span class="line">        2. 文件系统活动登录区(log section)</span><br><span class="line">          * 主要用来记录文件系统的变化，直至文件的变化完整的写入到数据区，该文件的该笔记录才会终结，文件系统意外中断后系统会依此登录区进行检验，来快速的修复文件系统</span><br><span class="line">          * 可指定外部的磁盘作为xfs的日志区块(因为读写频繁，可指定ssd)</span><br><span class="line">        3. 实时运作区(realtime section)</span><br><span class="line">          * 文件建立时，xfs在这一区段找一个或书个extent区块用来将文件放置在这个区块内，等到分配完毕，再写入data section的inode与block中</span><br><span class="line">          * 这个extent区块大小在格式化时要先指定[4K~1G]，默认即可，不要乱动[会影响到实际磁盘的效能]</span><br><span class="line">    + XFS文件系统的描述数据观察</span><br><span class="line">      * ```xfs_info 挂载点/装置文件名```</span><br><span class="line">      ![](1240-1647257376074106.png)</span><br><span class="line">      * 第一行，isize=inode的容量，agcount=储存区群组的个数，agsize=每个储存区群组具有65536个block，文件系统容量=4*65536*4k*(第四行bsize=4096=4k)</span><br><span class="line">      * 第二行，sectsz=逻辑扇区(sector)的容量</span><br><span class="line">      * 第四行，bsize=block的容量</span><br><span class="line">      * 第五行，sunit与swidth与磁盘阵列的stripe相关性较高</span><br><span class="line">      * 第七行，internal指的是这个登录区的位置在文件系统内，而非外部设备</span><br><span class="line">      * 第九行，realtime=none表示没有使用，extent容量=4k</span><br><span class="line">---</span><br><span class="line">- 文件系统的简单操作</span><br><span class="line">  - 磁盘与目录的容量</span><br><span class="line">    + df</span><br><span class="line">      - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>df [-ahikHTm] [目录或文件名]</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    1. -a：列出所有文件系统，包括特有的/proc等文件系统</span><br><span class="line">    2. -k：以kbytes的容量显示</span><br><span class="line">    3. -m：以mbytes的容量显示</span><br><span class="line">    4. -h：以较易阅读的格式显示(G,M,K)</span><br><span class="line">    5. -H：以m=1000k取代m=1024k的方式</span><br><span class="line">    6. -T：连同partition的filesystem名称(eg：xfs)也列出来</span><br><span class="line">    7. -i：不用磁盘容量，而以inode的数量来显示   </span><br><span class="line">  - 字段含义</span><br><span class="line">    1. filesystem：代表文件系统是在哪个partition</span><br><span class="line">    2. 1k-blocks：底下的数字单位是1kb</span><br><span class="line">    3. used：使用掉的硬盘空间</span><br><span class="line">    4. available：剩下的磁盘空间大小</span><br><span class="line">    5. use%：磁盘使用率</span><br><span class="line">    6. mounted on：挂载点</span><br><span class="line">  - 有个/dev/shm的目录是内存虚拟出来的磁盘空间哈，通常是总物理内存的一半</span><br><span class="line">+ du</span><br><span class="line">  - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>du [-ahskm] 文件或目录名称</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      1. -a列出所有的目录与文件容量</span><br><span class="line">      2. -h：同df</span><br><span class="line">      3. -s：列出总量，而不列出每个目录的占用容量</span><br><span class="line">      4. -S：不包括子目录的统计，与-s有差别</span><br><span class="line">      5. -k，-m：同上</span><br><span class="line">    - 直接输入du不加选项，du会分析当前目录的文件与目录所占用的磁盘空间，实际显示时仅会显示目录容量(不含文件)</span><br><span class="line">- 实体链接与符号链接</span><br><span class="line">  + Hard link(实体链接、硬链接or实际链接)</span><br><span class="line">    - 有没有可能多个档名对应到同一个inode？**hard link就是在某个目录下新增一笔档名链接到某个inode号码的关联记录**</span><br><span class="line">    - 建立实体链接的指令</span><br><span class="line">      `ln 目标文件名 将建立实体链接的文件名`</span><br><span class="line">    - 示意图</span><br><span class="line">      ![](1240-1647257378728108.png)</span><br><span class="line"></span><br><span class="line">    - 建立实体链接的好处</span><br><span class="line">      * 安全：将任何一个文件删除后，inode与block都依然存在，可通过另一个档名来读取到正确的文件数据</span><br><span class="line">    - 有没有可能hard link改变block呢，有，新增数据正好将目录的block填满时则需要再加一个block来记录时</span><br><span class="line">    - hard link的限制</span><br><span class="line">      * 不能跨filesystem</span><br><span class="line">      * 不能link目录</span><br><span class="line">  + Symbolic link(符号链接)</span><br><span class="line">    - symbolic link就是建立一个独立的文件，当数据读取时这个文件会指向他link的文件的档名，当源档被删除后，符号链接的文件将找不到原始的档名</span><br><span class="line">    - 建立符号链接的指令</span><br><span class="line">      `ln -s 目标文件名 将建立符号链接的文件名`</span><br><span class="line">    - 连结档的重要内容就是他会写上目标文件的文件名(ll可以看到连结档的的大小其实就是目标文件名的路径)</span><br><span class="line">    - 示意图</span><br><span class="line">      ![](1240-1647257380745110.png)</span><br><span class="line">  + ln</span><br><span class="line">    - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>ln [-sf] 来源文件 目标文件</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  -s:如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link</span><br><span class="line">  -f:如果目标文件存在时，就主动的将目标文件直接移除后再建立</span><br><span class="line">- eg</span><br></pre></td></tr></table></figure>
cd &#x2F;tmp;cp -a &#x2F;etc&#x2F;passwd<br>du -sb;df -i .(计算&#x2F;tmp下有多少个bytes的容量，使用了多少inode)<br>ln passwd passwd_hd(实体链接)<br>du -sb;df -i .(观察)<br>ln -s passwd passwd_so(符号链接)<br>du -sb;df -i .(观察)<br>ll -i passwd*(观察)</li>
<li>关于目录的link数量<ul>
<li>新建一个目录，会有三样东西，目录本身，“.”，”..”，”.”指向目录本身，”..”指向上层目录，so…<strong>新的目录link数为2，上层目录的link数增加1</strong></li>
</ul>
</li>
<li>一点点补充：简单点记录，软链接就是我在我的block存了你的inode，硬链接就是我和你共用一个inode</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>磁盘的分区、格式化、检验与挂载<ul>
<li>新增一颗磁盘时的动作<ol>
<li>对磁盘进行分区，以建立可用的 partition</li>
<li>对该 partition 进行格式化 (format)，以建立系统可用的 filesystem</li>
<li>若仔细一点，则对刚刚建立好的 filesystem 进行检验</li>
<li>在 Linux 系统上，需要建立挂载点 (亦即是目录)，并将他挂载上来</li>
</ol>
</li>
</ul>
<ul>
<li>观察磁盘分区状态<ul>
<li>lsblk 列出系统上的所有磁盘列表<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1.   lsblk [-dfimpt] [device]</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
-d ： 仅列出磁盘本身，并不会列出该磁盘的分区数据<br>-f ：同时列出该磁盘内的文件系统名称<br>-i ：使用 ASCII 的方式输出，不使用复杂的编码<br>-m ：同时输出该装置在 &#x2F;dev 底下的权限数据 (rwx 的数据)<br>-p ：列出该装置的完整文件名<br>-t ：列出该磁盘装置的详细数据，包括磁盘队列机制、 预读写的数据量大小等</li>
<li>一些字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      NAME:装置的文件名(省略/dev等前导目录)</span><br><span class="line">      MAJ:MIN:主要:次要装置代码(核心认识的装置都是透过这两个代码熟悉的)</span><br><span class="line">      RM:是否为可卸除装置(usb、光盘...etc)</span><br><span class="line">      SIZE:容量</span><br><span class="line">      RO:是否为只读装置</span><br><span class="line">      TYPE:是磁盘(disk)，分区(partition)还是只读存储器(rom)等</span><br><span class="line">      MOUNTPOINT:挂载点</span><br><span class="line">    - eg</span><br><span class="line">      1. 列出/dev/sda装置内所有数据的完整文件名</span><br><span class="line">          ```lsblk -ip /dev/sda```</span><br><span class="line">      2. 列出装置的UUID参数</span><br><span class="line">          **UUID：全局单一标识符，Linux将系统内所有的装置都给予一个独一无二的标识符，可用来挂载or使用**</span><br><span class="line">          ```blkid```</span><br><span class="line">      3. parted列出磁盘的分区表类型与分区信息</span><br><span class="line">          ```parted device_name print```</span><br><span class="line">          几个字段</span><br><span class="line">          Model:磁盘的模块名(厂商</span><br><span class="line">          Disk /dev/sda:磁盘的总容量</span><br><span class="line">          Partition Table:分区表格式(MBR/GPT)</span><br><span class="line">- 磁盘分区:gdisk/fdisk</span><br><span class="line">  + __MBR分区使用fdisk分区，GPT分区使用gdisk分区</span><br><span class="line">  + gdisk(不需要背)</span><br><span class="line">    * gdisk 装置名称</span><br><span class="line">      eg：</span><br></pre></td></tr></table></figure>
gdisk &#x2F;dev&#x2F;sda<br>几个常用的指令<br>d delete a partition  删除一个分区<br>n add a new partition  增加一个分区<br>p print the partition table  印出分区表 (常用)<br>q quit without saving changes  不储存分区就直接离开 gdisk<br>w write table to disk and exit  储存分区操作后离开 gdisk</li>
</ul>
<ul>
<li>使用gdisk不要背，？之后就全都可以看到(可以随便玩，别按w，按q就行了)</li>
<li>p列出目前磁盘分区表信息后的几个字段<ol>
<li>Number：分区表编号，1指的是&#x2F;dev&#x2F;sda1</li>
<li>Start(sector)：每一个分区槽开始扇区号码位置</li>
<li>End(sector)：每一个分区的结束扇区号码位置，与 start 之间可以算出分区槽的总容量</li>
<li>Size：分区槽容量</li>
<li>Code：分区槽内可能的文件系统类型，linux为8300，swap为8200(只是一个提示，不见得真的代表分区槽内的文件系统)</li>
<li>Name：文件系统的名称</li>
</ol>
</li>
<li><strong>几点重要的结论</strong><ol>
<li><strong>可以看到最大扇区数及目前使用到的扇区数，可以进行额外的分区</strong></li>
<li><strong>新分区通常选用上一个分区的结束扇区号码+1作为起始扇区号码</strong></li>
<li>gdisk只有root可以执行，使用的装置文件名eg:&#x2F;dev&#x2F;sda，而不要使用&#x2F;dev&#x2F;sda1,因为我们是对整个磁盘进行分区而不是某个分区进行分区</li>
</ol>
</li>
<li>用gdisk新增分区槽(下面是假设需求)<br>     1GB 的 xfs 文件系统 (Linux)<br>     1GB 的 vfat 文件系统 (Windows)<br>     0.5GB 的 swap (Linux swap)<br>     S1：这里只需要注意Last sector不要使用默认值即可，使用+1G的方式，gdisk会根据填写的数值直接计算出最接近该容量的扇区数，分区后可按p查看结果，无误则w写入(btw关于文件系统的id[Linux一般是8200&#x2F;8300&#x2F;8e00，windows几乎都用0700]，可按L查看)<br>     S2：cat &#x2F;proc&#x2F;partitions，发现没有新的分区，是因为linux还在使用磁盘，分区表还未更新，两种解决方法，重启or partprobe指令</li>
<li>partprobe更新Linux核心的分区表信息<figure class="highlight plaintext"><figcaption><span>[-s]```不加-s屏幕就不会出现信息，建议加</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      then，使用lsblk 装置名查看实际的磁盘分区状态，cat /proc/partitions查看核心的分区记录，都可以看到最新的分区</span><br><span class="line">    * 用gdisk删除一个分区槽</span><br><span class="line">      直接在选项中选d并选择分区号即可，**注意要去处理一个正在使用的分区槽，必须要先卸除**</span><br><span class="line">  + fdisk</span><br><span class="line">    * 输入m后可看到指令介绍，与gdisk没差啦</span><br><span class="line">- 磁盘格式化(建立文件系统)</span><br><span class="line">  + XFS文件系统 mkfs.xfs</span><br><span class="line">    - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f]  [-r parms] 装置名称</li>
</ol>
</li>
</ul>
<ul>
<li>选项与参数<br>关于单位：底下只要谈到『数值』 时， 没有加单位则为 bytes 值，可以用 k,m,g,t,p (小写)等来解释<br>比较特殊的是 s 这个单位，它指的是 sector 的『个数』喔！</li>
</ul>
<p>-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！<br>-d ：后面接的是重要的 data section 的相关参数值，主要的值有：<br>agcount&#x3D;数值 ： 设定需要几个储存群组的意思(AG)，通常与 CPU 有关<br>agsize&#x3D;数值 ：每个 AG 设定为多少容量的意思，通常 agcount&#x2F;agsize 只选一个设定即可</p>
</li>
<li>EXT4文件系统 mkfs.ext4  <ul>
<li>用法一样，更多直接mkfs tab tab就可以看见</li>
</ul>
</li>
</ul>
</li>
<li>文件系统检验<ul>
<li>xfs_repair处理XFS文件系统<ul>
<li>使用xfs_repair [-fnd] &#x2F;dev&#x2F;sda1,-f代表后面是文件而不是实体设备，-n代表单纯检查而已，-d代表对根目录进行检查和修复，danger，danger，哈哈哈哈,修复挂载</li>
</ul>
</li>
<li>fsck.ext4处理EXT4文件系统<ul>
<li>fsck tab tab可以看见很多针对不同文件系统的修复</li>
<li>选项就记个-p：自动回复ｙ来继续进行修复动作，和一个-b：利用文件系统内备份的superblock尝试救援</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Recover：<br>解除挂载时，提示devise is busy，可以使用fuser -mv 挂载点查看是哪个进程正在占用<br>tune2fs,修改卷标，最大挂载次数等等，同时e2label 设备名 卷标也可以修改<br>注意修改分区后一定要记得partprobe，然后格式化分区，swap分区需要使用swapon 设备名称激活，关闭使用swapoff【cat &#x2F;proc&#x2F;swaps 】【修改卷标的意义在哪里呢：接下来挂载时可以直接使用 mount LABEL&#x3D;卷标名称 挂载点进行挂载，注意如果是挂载镜像时，类型要写iso9660，权限是defaults,loop】<br>还可以怎样创建一个swap分区呢，dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file bs&#x3D;1M count&#x3D;100,这样就创建了一个100M的file文件，接着格式化：mkswap file，然后swapon file激活，紧接着在cat proc&#x2F;swaps的时候就可以看到新的swap分区了，值得注意的是swap分区使用的是file占用的空间而不是其本身，然后可以给他设置开机自动挂载</p>
<ul>
<li>文件系统的简单操作<ul>
<li>磁盘与目录的容量：df显示所有已挂载文件系统及其容量，du显示文件、目录的容量<br> 常用：df -hT（h即以方便读的容量显示，T会显示出文件系统的类型）,du -sh（s即查看总大小）</li>
<li>ln创建链接文件<br> 常用：ln -sf 目标文件名 将建立链接的文件名（s是符号链接，不加就是硬链接，f是删除已存在的链接文件）</li>
</ul>
</li>
</ul>
<p>日志文件系统<br>各个blockgroup的基本结构为superblock+文件系统描述信息+blosk位图+inode位图+inode表+block，所以ext3–&gt;ext2系统多了的日志记录功能在于文件进行写入操作时记录日志，避免某个步骤中断导致的元数据与实际数据不一致</p>
<p>VFS（虚拟文件系统）<br>linux中多种文件系统，eg ext2、ext3、vfa…etc，那么VFS存在的意义是什么呢，我们的程序可以不关注实际的文件系统是什么，</p>
<p>fdisk<br>查看分区：-l:display partitions and exit,单独查看某一分区就直接fdisk -l &#x2F;dev&#x2F;sda1<br>分区：fidsk &#x2F;dev&#x2F;sda(注意是对硬盘进行分区而不是对分区进行分区，不要写为fdisk dev&#x2F;sda1)<br>为什么一个硬盘只能划分 主分区+扩展分区&lt;&#x3D;4个，因为一个硬盘的MBR区一共512字节，512字节&#x3D;446(引导程序)+64(分区表)+2(结束符号)，但是标记一个分区需要16字节，所以要是想划分多个分区就在扩展分区里划分逻辑分区吧<br>修改分区后的操作：partprobe更新分区表–&gt;mkfs格式化分区–&gt;挂载</p>
<p>挂载<br>挂载：标准格式：mount -o 选项 -t 文件系统，一般使用的就是mount 需挂载的设备 挂载点；解除挂载：umount 外部设备or挂载点；重新挂载eg：mount -o remount &#x2F;mnt（挂载）;几种选项，rw，ro，noexec，exec；解除挂载是可以使用fuser -mv 设备名称查看正在使用挂载点的程序<br>磁盘检验：fsck &#x2F;dev&#x2F;sda5(-f：强制自检；-C 显示过程)，badblocks  dev&#x2F;sda3<br>开机自动挂载：&#x2F;etc&#x2F;fstab 写入，blkid可以显示出所需要的uuid，同时注意1.文件系统不要写错了；2后面的两位数字，第一个为是否启动备份，第二个为是否使用fsck自检<br>磁盘参数修改：tune2fs<br>特殊设备挂载：镜像文件不可路就挂载使用，eg：mount -o loop 镜像 挂载点</p>
<p>内存交换空间（swap）的构建<br>使用物理分区构建：就是常规的fdisk创建一个分区，记得了类型选对，格式化（mkswap），激活（swapon）<br>使用文件构建：dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file bs&#x3D;100M count&#x3D;100,然后格式化并激活</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/">
                第六章、Linux文件与目录管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/鸟哥的Linux私房菜-读书笔记/">鸟哥的Linux私房菜-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <ul>
<li>#目录与路径<ul>
<li>##绝对路径与相对路径：略</li>
<li>##目录的相关操作<ul>
<li>####几个特殊目录<ul>
<li><strong>.</strong> 代表此层目录</li>
<li><strong>..</strong> 代表上一层目录</li>
<li><strong>-</strong> 代表前一个工作目录</li>
<li><strong>~</strong> 代表『目前用户身份』所在的家目录</li>
<li>**~**account 代表 account 这个用户的家目录(account 是个账号名称)</li>
</ul>
</li>
</ul>
</li>
<li>##几个常见处理目录的指令<ul>
<li>####cd(change directory, 变换目录)</li>
<li>####pwd(显示目前所在的目录)<ul>
<li>选项与参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1. [-P]：显示出实际路径而非(link)路径</span><br><span class="line">+ mkdir(建立新目录)</span><br><span class="line">  - 选项与参数：</span><br></pre></td></tr></table></figure>
<ol>
<li>-m:指定文件权限而不需要看预设权限(umask)<br>  eg：mkdir -m 711 file_name</li>
<li>-p：直接将需要的目录递归创建起来<br>  eg：mkdir -p a&#x2F;b&#x2F;c&#x2F;d</li>
</ol>
</li>
</ul>
</li>
<li>rmdir(删除[空]目录)<ul>
<li>选项与参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      1. -p：连同『上层』『空的』目录也一起删除</span><br><span class="line">- ## 关于执行文件路径的变量：$PATH</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>echo $PATH：显示目前的PATH,执行顺序即搜到的顺序</li>
<li>添加PATH：PATH&#x3D;”${PATH}:&#x2F;root”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    + 不同身份预设的PATH不同，默认能够随意执行的指令也不同</span><br><span class="line">---</span><br><span class="line">- #文件与目录管理</span><br><span class="line">  + ####文件与目录检索：ls</span><br><span class="line">    * 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>ls [-aAdfFhilnrRSt] 文件名或目录名称</li>
<li>ls [–color&#x3D;{never,auto,always}] 文件名或目录名称</li>
<li>ls [–full-time] 文件名或目录名称</li>
</ol>
</li>
</ul>
<ul>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    1. -a ：全部的文件， 连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</span><br><span class="line">    2. -A ：全部的文件， 连同隐藏档，但不包括 . 与 .. 这两个目录</span><br><span class="line">    3. -d ： 仅列出目录本身，而不是列出目录内的文件数据(常用)</span><br><span class="line">    4. -f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！ )</span><br><span class="line">    5. -F ：根据文件、目录等信息， 给予附加数据结构，例如： *:代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；</span><br><span class="line">    6. -h ： 将文件容量以易读的方式(例如 GB, KB 等等)列出来；</span><br><span class="line">    7. -i ：列出 inode 号码；</span><br><span class="line">    8. -l ： 长数据串行出，包含文件的属性与权限等等数据； (常用)</span><br><span class="line">    9. -n ：列出 UID 与 GID 而非使用者与群组的名称</span><br><span class="line">    10. -r ： 将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；</span><br><span class="line">    11. -R ： 连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</span><br><span class="line">    12. -S ：以文件容量大小排序，而不是用档名排序；</span><br><span class="line">    13. -t ：依时间排序，而不是用档名。</span><br><span class="line">    14. --color=never ：不要依据文件特性给予颜色显示；</span><br><span class="line">    15. --color=always ： 显示颜色</span><br><span class="line">    16. --color=auto ： 让系统自行依据设定来判断是否给予颜色</span><br><span class="line">    17. --full-time ：以完整时间模式 (包含年、月、日、 时、分) 输出</span><br><span class="line">    18. --time=&#123;atime,ctime&#125; ： 输出 access 时间或改变权限属性时间 (ctime)而非内容变更时间 (modification time)</span><br><span class="line">    eg:ll -alF --color=never --full-time ~</span><br><span class="line">+ ####复制、删除和移动：cp/rm/mv</span><br><span class="line">  * 语法：</span><br></pre></td></tr></table></figure>
<ol>
<li>cp [-adfilprsu] 来源文件(source) 目标文件(destination)</li>
<li>cp [options] source1 source2 source3 …. directory</li>
</ol>
</li>
<li>选项和参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    1. -a ：相当于 -dr --preserve=all  (常用)</span><br><span class="line">    2. -d ：若来源文件为链接文件的属性(link file)， 则复制链接文件属性而非文件本身；</span><br><span class="line">    3. -f ： 为强制(force)的意思，若目标文件已经存在且无法开启， 则移除后再尝试一次；</span><br><span class="line">    4. -i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</span><br><span class="line">    5. -l ： 进行硬式连结(hard link)的连结档建立，而非复制文件本身；</span><br><span class="line">    6. -p ： 连同文件的属性(权限、用户、 时间)一起复制过去，而非使用默认属性(备份常用)；</span><br><span class="line">    7. -r ： 递归持续复制，用于目录的复制行为； (常用)</span><br><span class="line">    8. -s ：复制成为符号链接文件 (symbolic link)；</span><br><span class="line">    9. -u ： destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</span><br><span class="line">    10. --preserve=all ：除了 -p 的权限相关参数外， 还加入 SELinux 的属性, links, xattr 等也复制了。</span><br><span class="line">    注：如果source有两个以上，destination必须得是目录</span><br><span class="line">  * 在预设条件中，cp的源文件与目标文件的权限事不同的，目标文件的拥有者通常事指令操作者本身，三思而后复制哈哈</span><br><span class="line">+ ####rm (移除文件或目录)</span><br><span class="line">  * 选线和参数：  </span><br></pre></td></tr></table></figure>
<ol>
<li>-f：(force) ，忽略不存在的文件，不会出现警告讯息</li>
<li>-i：删除前询问使用者</li>
<li>-r：递归删除</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>####mv (移动文件与目录，或更名)</p>
<ul>
<li>语法：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1. mv [-fiu] source destination</span><br><span class="line">  2. mv [options] source1 source2 source3 .... directory</span><br><span class="line">* 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-f：如果目标文件已经存在，不会询问而直接覆盖</li>
<li>-i：若目标文件 (destination) 已经存在时，就会询问是否覆盖</li>
<li>-u：若目标文件已经存在，且 source 比较新，才会更新 (update)</li>
</ol>
</li>
</ul>
</li>
<li><p>取得路径的文件名与目录名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1. basename /etc/sysconfig/network--&gt;network</span><br><span class="line">    2. dirname /etc/sysconfig/network--&gt;/etc/sysconfig</span><br><span class="line">---</span><br><span class="line">- #文件内容查阅</span><br><span class="line">  + ##直接查看文件内容</span><br><span class="line">    * ####cat(concatenate)</span><br><span class="line">      选项与参数：</span><br></pre></td></tr></table></figure>
<ol>
<li>-A ：等于 -vET</li>
<li>-b ：列出行号， 仅针对非空白行做行号显示</li>
<li>-E ： 显示结尾断行符 $ </li>
<li>-n ：列出行号， 连同空白行也会有行号</li>
<li>-T ： 将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ol>
<ul>
<li>####tac(反向显示)</li>
<li>####nl(添加行号打印)<br>选项和参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    1. -b ：指定行号指定的方式，主要有两种：</span><br><span class="line">        -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</span><br><span class="line">        -b t ：如果有空行，空的那一行不要列出行号(默认值)；</span><br><span class="line">    2. -n ：列出行号表示的方法，主要有三种：</span><br><span class="line">        -n ln ：行号在屏幕的最左方显示；</span><br><span class="line">        -n rn ：行号在自己字段的最右方显示，且不加 0 ；</span><br><span class="line">        -n rz ：行号在自己字段的最右方显示，且加 0 ；</span><br><span class="line">    3. -w ：行号字段的占用的字符数。</span><br><span class="line">+ ##可翻页查看</span><br><span class="line">  * ####more (一页一页翻动)</span><br><span class="line">    选项和参数：</span><br></pre></td></tr></table></figure>
<ol>
<li>空格键 (space)：代表向下翻一页</li>
<li>Enter ：代表向下翻『一行』</li>
<li>&#x2F;字符串 ：代表在这个显示的内容当中，向下搜寻『字符串』这个关键词</li>
<li>f ：立刻显示出文件名以及目前显示的行数</li>
<li>q ：代表立刻离开 more ，不再显示该文件内容</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用</li>
</ol>
</li>
<li>####less (一页一页翻动，man就是使用less来显示说明文件的)<br>选项和参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    1. 空格键 ：向下翻动一页；</span><br><span class="line">    2. [pagedown]：向下翻动一页；</span><br><span class="line">    3. [pageup] ：向上翻动一页；</span><br><span class="line">    4. /字符串 ：向下搜寻『字符串』的功能；</span><br><span class="line">    5. ?字符串 ：向上搜寻『字符串』的功能；</span><br><span class="line">    6. n ：重复前一个搜寻 (与 / 或 ? 有关！ )</span><br><span class="line">    7. N ：反向的重复前一个搜寻 (与 / 或 ? 有关！ )</span><br><span class="line">    8. g ：前进到这个资料的第一行去；</span><br><span class="line">    9. G ：前进到这个数据的最后一行去 (注意大小写)；</span><br><span class="line">    10. q ：离开 less 这个程序；</span><br><span class="line">+ ##资料撷取</span><br><span class="line">  * ####head (取出前面几行)</span><br><span class="line">    - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>head [-n number] 文件</li>
</ol>
<ul>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1. -n ：后面接数字，代表显示几行，不加此选项默认显示十行，如为负数代表显示负数绝对值前面的行</span><br><span class="line">* ####tail (取出后面几行)</span><br><span class="line">  - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>head [-n number] 文件</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      1. -n ：后面接数字，代表显示几行，如选项为+n，则代表显示n行以后的数据</span><br><span class="line">      2. -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c 才会结束 tail 的侦测</span><br><span class="line">  * 非纯文本档： od(我觉得自己暂时用不到O(∩_∩)O)</span><br><span class="line">+ ##修改文件时间或建置新档： touch</span><br><span class="line">  * 文件的三个主要变动时间</span><br><span class="line">    1. modification time (mtime)：文件的内容数据(文件的内容，非属性或权限)变更时的时间</span><br><span class="line">    2. status time (ctime)：当文件的状态(比如权限和属性)改变时会更新的时间</span><br><span class="line">    3. access time (atime)：当文件的内容被读取时候会更新的读取时间</span><br><span class="line">  * ls默认情况显示的是文件的mtime，其余可用ls -l --time=&#123;atime，ctime&#125;来查看</span><br><span class="line">  * 语法</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>touch [-acdmt] 文件</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      1. -a ： 仅修改access time；</span><br><span class="line">      2. -c ： 仅修改文件的时间，若该文件不存在则不建立新文件(全都修改了)</span><br><span class="line">      3. -d ：后面可以接欲修订的日期而不用目前的日期，也可以使用--date=&quot;日期或时间&quot;(atime/mtime)</span><br><span class="line">      4. -m ： 仅修改 mtime ；</span><br><span class="line">      5. -t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]）(atime/mtime)</span><br><span class="line">---</span><br><span class="line">- #文件与目录的默认权限与隐藏权限</span><br><span class="line">  + ##文件预设权限：</span><br><span class="line">      umask(目前用户在建立文件or目录时的权限默认值，可直接通过umask value设定)</span><br><span class="line">    * ####两种查阅方式：</span><br><span class="line">      1. 直接输入umask，可见到数字形态的权限设定</span><br><span class="line">      2. 加上-S可以符号形式来显示</span><br><span class="line">      3. 注：为啥有四组，第一组是特殊权限</span><br><span class="line">    * ####两种预设情况</span><br><span class="line">      1. 目录：drwxrwxrwx，建立目录时： (drwxrwxrwx) - (d----w--w-) ==&gt; drwxr-xr-x</span><br><span class="line">      2. 文件：-rw-rw-rw-，建立文件时： (-rw-rw-rw-) - (-----w--w-) ==&gt; -rw-r--r--</span><br><span class="line">  + ##文件隐藏属性</span><br><span class="line">    * 注：chattr指令只在ext2/ext3/ext4的Linux传统文件系统完整生效，其他文件系统eg：xfs只支持部分参数</span><br><span class="line">    * ####chattr (配置文件案隐藏属性)</span><br><span class="line">      - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>chattr [+-&#x3D;][ASacdistu] 文件或目录名称</li>
</ol>
<ul>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  1. + ：增加某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">  2. - ：移除某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">  3. = ： 更新为指定参数</span><br><span class="line">  4. A：文件的atime(access time)不可被修改，这样可以减少磁盘I/O数量，对于笔记本电脑有利于提高续航能力</span><br><span class="line">  5. S：硬盘I/O同步选项，功能类似sync</span><br><span class="line">  6. a ： 当设定 a 之后， 这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性</span><br><span class="line">  7. c：即compresse，文件会自动的经压缩后再存储，读取时会自动的解压</span><br><span class="line">  8. d：不被dump程序备份</span><br><span class="line">  9. i：设定该属性后，可使得文件不能被删除、重命名、设定连接关系、写入或新增数据，仅有root可设定此属性</span><br><span class="line">  10. s：文件被删除后将被完全移除硬盘空间，不能救回</span><br><span class="line">  11. u：与s相反，文件删除后可救回</span><br><span class="line">- 注意</span><br></pre></td></tr></table></figure>
<ol>
<li>常见使用a与i，很多属性需要root才能设定</li>
<li>xfs文件系统仅支持AadiS</li>
</ol>
</li>
</ul>
</li>
<li>####lsattr(显示文件隐藏属性)<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. lsattr [-adR] 文件或目录</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-a ： 显示所有文件的隐藏权限，包括隐藏文件</li>
<li>-d：显示目录的属性而非目录内文件的属性</li>
<li>递归显示目录下文件和子目录的属性</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>##文件特殊权限：SUID,SGID,SBIT</p>
<ul>
<li>####Set UID<br>当s标志出现在文件owner的权限上时，(eg：&#x2F;usr&#x2F;bin&#x2F;passwd)此时被称为Set UID(简称SUID的特殊权限)<ul>
<li>SUID的限制有功能<ol>
<li>SUID权限仅对二进制程序有效(不能用在shell script上)</li>
<li>执行者需对该程序有x权限</li>
<li>SUID权限仅仅在执行该程序的过程中有效</li>
<li>执行者在此过程中将具有该程序owner的权限</li>
</ol>
</li>
<li>这里给的例子真的是让人一下就明白了，&#x2F;etc&#x2F;shadow的权限为———- 1 root root，但是一个一般账号也可以通过passwd指令来修改密码呀，这就是SUID的功能啦，&#x2F;usr&#x2F;bin&#x2F;passwd的权限是rwsr-xr-x，所以一般账号也有x权限，临时借用了一下root的权限对etc&#x2F;shadow进行修改</li>
</ul>
</li>
<li>####Set GID<br>当s标志在文件group权限上时，称为Set GID(简称SGID),(eg &#x2F;usr&#x2F;bin&#x2F;locate)<ul>
<li>与SUID不同，SGID可以针对文件或目录及来设置<ul>
<li>对文件<ol>
<li>SGID对二进制程序有效</li>
<li>执行者需要对该程序有x的权限</li>
<li>执行者在执行过程中将会得到程序群组的支持</li>
</ol>
</li>
</ul>
<ul>
<li>eg，locate可以搜寻&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db中的内容，mlocate.db的权限为-rw-r—–，locate的权限为-rwx–s–x，那么一般账号在执行locate时将会在执行过程中的到slocate群组的支持，于是才能读取mlocate.db的内容</li>
</ul>
</li>
</ul>
<ul>
<li>对目录<ol>
<li>用户对于此目录具有r与x权限时，该用户能够进入此目录</li>
<li>用户在此目录下的有效群组将会变成该目录的群组</li>
<li>用途：若用户在此目录具有w的权限，则使用则锁建立的新文件，该新文件的群组与此目录的群组相同</li>
</ol>
</li>
</ul>
</li>
<li>####Sticky Bit<br>(简称SBIT)，只针对目录有效<ul>
<li>对目录<ol>
<li>当用户对此目录具有w权限(具有group或others的权限时)</li>
<li>当用户在该目录下建立文件or目录时，仅有自己与root才有权力删除&#x2F;重命名&#x2F;移动文件</li>
</ol>
</li>
<li>eg：以不同用户在tmp下建立文件，切换用户尝试删除操作</li>
</ul>
</li>
<li>SUID&#x2F;SGID&#x2F;SBIT权限设定<ul>
<li>4：SUID</li>
<li>2：SGID</li>
<li>1：SBIT</li>
<li>eg：需要将一个文件权限修改为-rwsr-xr-x，即加入SUID权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      chmod  4755 filename  </span><br><span class="line">      顺便试一下其他几种情况</span><br><span class="line">      chmod  6755 filename</span><br><span class="line">      chmod  1755 filename</span><br><span class="line">      chmod  7666 filename，(这种情况下会出现S和T，这是因为文件本身都不具有x的权限，想一想SUID时文件执行时具有文件owner的权限，既然都不能执行，哪来的的权限借用，所以S、T代表就是“空的”的意思)</span><br><span class="line">       这是符号法来处理(个人认为不如数字法方便)</span><br><span class="line">       chmod u=rwxs，go=x filename</span><br><span class="line">       chmod g+s，o+t filename</span><br><span class="line">+ ##观察文件类型：file</span><br><span class="line">  * 如果想知道某个文件的基本数据类型，可以使用file</span><br><span class="line">  * 语法</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>file filename</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>#指令与文件的搜索<ul>
<li>##脚本文件名的搜索<ul>
<li>####which<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. which [-a] command</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-a：将所有PATH目录中可以找到的指令列出而不仅仅是列出第一个被找到的指令名称</li>
</ol>
</li>
<li>注:which预设找PATH内所规范的目录，但是找不到bash内建的指令，eg：which history是找不到的</li>
</ul>
</li>
</ul>
</li>
<li>文件档名的搜寻<ul>
<li>####whereis(有一些特定的目录中寻找文件文件名)<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. whereis [-bmsu] 文件或目录名</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-l：列出whereis会查询的几个主要目录</li>
<li>-b：执照二进制格式的文件</li>
<li>-m：只找在说明文件manual路径下的文件</li>
<li>-s：只找source来源文件</li>
<li>-u：搜寻不在上面三个选项中的其他特殊文件</li>
</ol>
</li>
</ul>
</li>
<li>####locate&#x2F;updatedb<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. locate [-ir] keyword</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-i：忽略大小写差异</li>
<li>-c：不输出档名，仅计算找到的数据量</li>
<li>-l：输出几行的意思，eg，输出5行： -l 5</li>
<li>-S：输出locate所使用数据库文件的相关信息，包括该数据库记录的文件&#x2F;目录数量…etc</li>
<li>-r：后面可接正则表达式的显示方式</li>
</ol>
</li>
<li>注：locate搜索快的原因是因为他是经由数据库搜寻的，而在CentOS7.x中数据库是每天更新一次的，所以可能对于新建立的文件无法搜寻到，需要使用updatedb读取&#x2F;etc&#x2F;updatedb.conf配置更新数据库<ol>
<li>updatedb：根据&#x2F;etc&#x2F;updatedb.conf的设置搜寻硬盘内文件名并跟新&#x2F;var&#x2F;lib&#x2F;mlocate内的数据库文件</li>
<li>locate：根据&#x2F;var&#x2F;lib&#x2F;mlocate的数据库记载找出用户输入的关键词文件名</li>
</ol>
</li>
</ul>
</li>
<li>####find<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. find [PATH] [option] [action]</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明</li>
</ol>
<p>  -mtime n ： n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；<br>  -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；<br>  -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。<br>  -newer file ： file 为一个存在的文件，列出比 file 还要新的文件档名<br>2. 与使用者或组名有关的参数：<br>  -uid n ： n 为数字， 这个数字是用户的账号 ID，亦即UID ， 这个 UID 是记录在&#x2F;etc&#x2F;passwd 里面与账号名称对应的数字。<br>  -gid n ： n 为数字， 这个数字是组名的 ID，亦即 GID， 这个 GID 记录在&#x2F;etc&#x2F;group<br>  -user name ：查找符合指定的拥有者名称的文件或目录<br>  -group name： 查找符合指定的组名称的文件或目录<br>  -nouser：找出不属于本地主机用户识别码的文件或目录(通过这个指令可以轻易找到不太正常的文件，但是如果找到也不要紧张，有时是正常的~尤其是以原始码自行编译软件时候)<br>  -nogroup：找出不属于本地主机群组识别码的文件或目录<br>3. 与文件权限即名称有关的参数<br>  -name filename：搜寻文件名为 filename 的文件<br>  -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。 这个 SIZE 的规格有：c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB还要大的文件，就是『-size +50k 』<br>  -type TYPE：搜寻文件的类型为 TYPE 的， 类型主要有：一般正规文件 (f), 装置文件 (b, c),目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性<br>  -perm mode：搜寻文件权限刚好等于mode的文件，mode类似于chmod的属性值，eg：-rwsr-xr-x 的属性为 4755<br>  -perm -mode：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，比如4755包括0744啦<br>  -perm &#x2F;mode：搜寻文件权限『包含任一 mode 的权限』的文件，就是会搜索到他的子集啦<br>4. 额外可进行的动作<br>   -exec command： command 为其他指令， -exec 后面可再接额外的指令来处理搜寻到的结果<br>    -print：将结果打印到屏幕上(这是默认的)</p>
</li>
<li>几个例子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">        1. find / -name ”*passwd*“</span><br><span class="line">        2. find /run -type s</span><br><span class="line">        3. find / -perm /7000，这个比较有意思7000表示---s--s--t，那么搜索其子集的话呢，意味着具有SUID,SGID,SBIT权限的问价or目录会被列出</span><br><span class="line">        4. find /usr/bin /usr/sbin -perm /7000 -exec ls -l &#123;&#125; \;</span><br><span class="line">          &#123;&#125;代表由find找到的内容，或者说find的结果会被放置到&#123;&#125;中</span><br><span class="line">          -exec到\；之间是关键词，代表find额外的动作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      - 关于时间参数可参见下图：</span><br><span class="line">        +4 代表大于等于 5 天前的文件名： find /var -mtime +4</span><br><span class="line">        -4 代表小于等于 4 天内的文件名：find /var -mtime -4</span><br><span class="line">        4 则是代表 4-5 那一天的文件名：find /var -mtime 4</span><br><span class="line">       ![](https://upload-images.jianshu.io/upload_images/13107967-0f2f922e8c842009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">---</span><br><span class="line">- #权限与指令之间的关系</span><br><span class="line">  + ##让用户能进入某目录的基本权限：</span><br><span class="line">    1. 目录：用户对此目录至少有x权限</span><br><span class="line">    2. 额外：若过想查阅目录内文件名(ls)，需有r权限</span><br><span class="line">  + ##让用户在某个目录内读取一个文件的基本权限：</span><br><span class="line">    1. 目录：用户至少有x权限</span><br><span class="line">    2. 文件：用户至少有r权限</span><br><span class="line">  + ##让用户可修改一个文件的基本权限：</span><br><span class="line">    1. 目录：用户至少有x权限</span><br><span class="line">    2. 文件：用户至少对该文件有r，w权限</span><br><span class="line">  + ##用户建立一个文件的基本权限：</span><br><span class="line">    1. 目录：用户在该目录要有x，w权限</span><br><span class="line">  + ##用户进入某目录并执行目录内某个指令：</span><br><span class="line">    1. 目录：至少有x权限</span><br><span class="line">    2. 文件：至少有x权限</span><br><span class="line">---</span><br><span class="line">- #重点回顾</span><br><span class="line">  + ls 可以检视文件的属性，尤其 -d, -a, -l 等选项特别重要</span><br><span class="line">  + cat -n 与 nl 均可显示行号，但默认的情况下，空白行会不会编号并不相同</span><br><span class="line">  + 除了传统的 rwx 权限之外，在 Ext2/Ext3/Ext4/xfs 文件系统中，还可以使用 chattr 与 lsattr 设定及观察隐藏属性。 常见的包括只能新增数据的 +a 与完全不能更动文件的 +i 属性</span><br><span class="line">  + 新建文件/目录时，新文件的预设权限使用 umask 来规范。默认目录完全权限为 drwxrwxrwx， 文件则为-rw-rw-rw-</span><br><span class="line">  + 文件具有 SUID 的特殊权限时，代表当用户执行此一 binary 程序时，在执行过程中用户会暂时具有程序拥有者的权限</span><br><span class="line">  + 目录具有 SGID 的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同</span><br><span class="line">  + 目录具有 SBIT 的特殊权限时，代表在该目录下用户建立的文件只有自己与 root 能够删除</span><br><span class="line">- #课后问题</span><br><span class="line">  1. 假设系统中有两个账号，分别是 alex 与 arod ，这两个人除了自己群组之外还共同支持一个名为project 的群组。假设这两个用户需要共同拥有 /srv/ahome/ 目录的开发权，且该目录不许其他人进入查阅。 请问</span><br><span class="line">     该目录的权限设定应为何？(真的做一遍就明白了)</span><br></pre></td></tr></table></figure>
groupadd project<br>useradd -G project alex<br>useradd -G project arod<br>mkdir &#x2F;srv&#x2F;ahome<br>chgrp project &#x2F;srv&#x2F;ahome<br>chmod 2770 &#x2F;srv&#x2F;ahome</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>找出 &#x2F;etc 底下， 文件大小介于 50K 到 60K 之间的文件，并且将权限完整的列出 (ls -l)<br>  <code> find /etc -size +50k -a -size -60k -exec ls -l &#123;&#125; \;( -a 是 and 的意思)</code><br> 找出 &#x2F;etc 底下， 文件容量大于 50K 且文件所属人不是 root 的档名，且将权限完整的列出 (ls -l)<br> <code>find /etc -size +50k -a ! -user root -exec ls -ld &#123;&#125; \;</code><br> <code>find /etc -size +50k -a ! -user root -type f -exec ls -l &#123;&#125; \;( ! 代表的是反向选择)</code><br>找出 &#x2F;etc 底下，容量大于 1500K 以及容量等于 0 的文件<br> <code>find /etc -size +1500k -o -size 0(-o 就是或 (or) )</code></li>
</ol>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/">
                第五章、Linux的文件权限与目录配置
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/鸟哥的Linux私房菜-读书笔记/">鸟哥的Linux私房菜-读书笔记</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <ul>
<li>使用者与群组<ul>
<li>文件拥有者的概念<ul>
<li>owner</li>
<li>group</li>
<li>others</li>
</ul>
</li>
<li>Linux用户身份与群组记录的文件<ul>
<li>&#x2F;etc&#x2F;passwd：账号的相关信息</li>
<li>&#x2F;etc&#x2F;shadow：密码的相关信息</li>
<li>&#x2F;etc&#x2F;group：群组的相关信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Linux文件权限概念<ul>
<li>Linux文件属性<ul>
<li><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240.png"></li>
<li>上图分解如下：<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725724866579.png"></li>
<li>【1 】代表文件的类型和权限<ul>
<li>第一个字符代表这个文件是目录、文件or链接文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      1. d：目录</span><br><span class="line">      2. -：文件</span><br><span class="line">      3. l：连接档(link file)</span><br><span class="line">      4. b：可供储存的接口设备</span><br><span class="line">      5. c：表示串行端口设备，鼠标、键盘等</span><br><span class="line">    - 接下来的字符三个一组，r代表可读(read)，w代表可写(write)，x代表可执行(execute)</span><br><span class="line">      1. 第一组：文件拥有者可具备的权限</span><br><span class="line">      2. 第二组：加入此群组的账号的权限</span><br><span class="line">      3. 第三组：其他账号的权限</span><br><span class="line">  * 【2】代表有多少档名连结到此节点(i-node）</span><br><span class="line">    - 每个文件都会将他的权限记录到文件系统的i-node中，我们的目录树是使用文件名来记录的，因此每个文件名都会连结到一个i-node，这个数字代表有多少不同的文件名连结到一个i-node号码</span><br><span class="line">  * 【3】代表这个文件or目录的拥有者账号</span><br><span class="line">  * 【4】代表这个文件的所属群组</span><br><span class="line">  * 【5】代表这个文件的容量大小，默认单位bytes</span><br><span class="line">  * 【6】代表这个文件的创建日期or最近的修改日期[使用ls -l --full-time可以显示处完整的时间格式]</span><br><span class="line">  * 【7】这个文件的文件名</span><br><span class="line">- 改变文件属性与权限</span><br><span class="line">  * chgrp：改变所属群组[要被改变的组名在/etc/group已经存在]</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>语法 chgrp group_name [-R] dirname&#x2F;filename</li>
</ol>
</li>
<li>chown：改变文件拥有者[用户在&#x2F;etc&#x2F;passwd中已经存在]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1. 语法 chown [-R] 账号名称 文件or目录</span><br><span class="line">  2. 语法 chown [-R] 账号名称:组名 文件or目录,把&quot;:&quot;替换成&quot;.&quot;也行，但是有的文件名以&quot;.&quot;开始，所以还是用&quot;:&quot;吧</span><br><span class="line">* cp：复制  </span><br></pre></td></tr></table></figure>
<ol>
<li>语法 cp 源文件 目标文件[注：cp会复制执行者的属性和权限]</li>
</ol>
</li>
<li>chmod：改变权限<ul>
<li>数字类型改变文件权限<br>r：4，w：2，x：1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1. 语法：chmod [-R] xyz 文件or目录</span><br><span class="line">  2. eg：chmod 777 file_name</span><br><span class="line">- 符号类型改变文件权限</span><br></pre></td></tr></table></figure>
<ol>
<li>语法：chmod [ukga][&#x3D;+-][rwx] 文件or目录</li>
<li>eg：chmod u&#x3D;rwx，go&#x3D;rx file_name</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>目录与文件的权限意义<ul>
<li>权限对文件的重要性<ul>
<li>r：可读取文件实际内容</li>
<li>w：可编辑、新增or修改文件内容(不包括删除)</li>
<li>x：有系统执行权限</li>
</ul>
</li>
<li>权限对目录的重要性<ul>
<li>r：有读取目录结构列表的权限，也就是可以查询目录下的文件名数据，也就可用ls列出目录内容</li>
<li>w：有异动该目录结构列表的权限<ul>
<li>建立新的文件or目录</li>
<li>删除已经存在的文件or目录(忽视文件权限)</li>
<li>重命名文件or目录</li>
<li>移动该目录内文件or目录</li>
</ul>
</li>
<li>x：可否进入该目录成为工作目录</li>
<li><strong>注:要开放目录给别人浏览，至少也要r及x权限，但w权限要慎重</strong></li>
</ul>
</li>
<li>用户操作功能与权限<ul>
<li>假设有两个档名，&#x2F;dir1&#x2F;file1，&#x2F;dir2，现使用一般账号，那么这个账号对于&#x2F;dir1，&#x2F;dir1&#x2F;file1，&#x2F;dir2的最小权限<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725725264881.png"></li>
</ul>
</li>
</ul>
</li>
<li>Linux文件种类与扩展名<ul>
<li>文件种类(regular file)：<ul>
<li>正规文件<ul>
<li>纯文本文档(ASCII)</li>
<li>二进制文件(binary)</li>
<li>数据格式文件(data)：某些程序运行时需要读取的特定格式的文件，eg：登入时会将数据记录在&#x2F;var&#x2F;log&#x2F;wtmp文件中，这是个data file，可以被last指令读出，但如果你使用cat会读出乱码</li>
</ul>
</li>
<li>目录(directory)：第一个属性为[d]</li>
<li>连接档(link)：类似Windows快捷方式，第一个属性为[l]</li>
<li>设备和装置文件(device)<ul>
<li>区块(block)设备档：一些存储数据，以提供系统随机存取的接口设备，eg：硬盘，第一个属性为[b]</li>
<li>字符[character]设备文件：一些串行端口的接口设备，eg：键盘、鼠标，第一个属性属性为[c]</li>
</ul>
</li>
<li>资料接口文件(socket)：常用于在网络上的数据承接，常在&#x2F;run或&#x2F;tmp目录中看见，第一个属性为[s]</li>
<li>数据输送文件(FIFO，pipe)：FIFO(first-in-first-out)是一种特殊的文件类型，主要目的是解决多个程序同时存取一个文件所造成的错误问题，第一个属性为[p]</li>
</ul>
</li>
<li>Linux文件扩展名：只是为了区分，毕竟Linux执行只看权限<ul>
<li>*.sh：脚本</li>
<li><em>.tar，</em>Z，*.tar.gz，*.zip，*.tgz：经过打包的压缩文件</li>
<li><em>.html，</em>.php:网页相关文件</li>
</ul>
</li>
<li>Linux文件长度限制<ul>
<li>单一文件or目录最大允许文件名为255bytes，所以大概英文255个字符or中文128个字符[不知道谁的文件名会这么长]</li>
</ul>
</li>
<li>Linux文件名的限制<br>-：没啥，别瞎加特殊字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Linux目录配置<ul>
<li>Linux目录配置<br>*Linux目录配置的依据-FHS<ul>
<li>FHS(filesystem hierarchy standard)，主要目的是希望使用者知道已安装的软件通常放置在哪个目录下</li>
<li>FHS将目录定义为四种交互作用的形态，如下图：<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725725489383.png"><ul>
<li>可分享的：可分享给其他系统挂在使用的目录</li>
<li>不可分享的：自己机器上运作的装置文件or与程序相关的socket文件等</li>
<li>不变的：不经常变动的，eg：函数库，文件说明文件，系统管理员的主机服务配置文件等等</li>
<li>可变的：经常改变的数据</li>
</ul>
</li>
<li>FHS针对目录架构仅定义出三层目录：<ul>
<li>&#x2F;(root，根目录)：与开机系统有关</li>
<li>&#x2F;usr(unix software resource)：与软件安装&#x2F;执行有关</li>
<li>&#x2F;var(variable)：与系统运行过程有关</li>
</ul>
</li>
<li>根目录&#x2F;的意义与内容<ul>
<li>FHS标准建议：根目录所在分区槽越小越好，且程序安装的软件最好不要与根目录放在一个分区槽内，保持根目录越小越好，这样既保证效能也较不易发生问题<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725725840585.png"><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725726094087.png"><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725726434989.png"></li>
<li>上面是FHS针对根目录定义的标准，仅有这些，但下面的目录也非常重要<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725726667691.png"></li>
</ul>
</li>
<li>&#x2F;usr的意义和内容<ul>
<li>usr(unix software resource)，FHS建议所有的软件开发者将他们的数据合理的分别放置在该目录的此目录，不能自行建立该软件自己的独立目录，所有的系统默认的软件(发行版发布者提供的软件)都会放置在&#x2F;usr下(类似于windows[c:\windows(部分)+C:\Program files]两个目录的综合体)，所以刚安装完这个目录会占用最多的硬盘空间，一般建议目录有底下这些：<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725726899693.png"></li>
</ul>
</li>
<li>&#x2F;var 的意义与内容<ul>
<li>不同于&#x2F;usr 是安装时会占用较大硬盘容量的目录，&#x2F;var是在系统运作后渐渐占用硬盘容量的目录。 </li>
<li>&#x2F;var 目录主要针对常态性变动的文件，包括快取(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如 MySQL 数据库的文件等等。常见的次目录有：<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725727744595.png"></li>
</ul>
</li>
<li>针对FHS各家distributions的异同及CentOS的变化<ul>
<li>FHS仅仅定义出最上层(&#x2F;)及次层(&#x2F;usr, &#x2F;var)的目录内容应该要放置的文件或目录数据，而其他次级目录可随开发者自行配置，但差异性有限</li>
<li>CentOS 7较过去版本的不同之处<ul>
<li>&#x2F;bin –&gt; &#x2F;usr&#x2F;bin</li>
<li>&#x2F;sbin –&gt; &#x2F;usr&#x2F;sbin</li>
<li>&#x2F;lib –&gt; &#x2F;usr&#x2F;lib</li>
<li>&#x2F;lib64 –&gt; &#x2F;usr&#x2F;lib64</li>
<li>&#x2F;var&#x2F;lock –&gt; &#x2F;run&#x2F;lock</li>
<li>&#x2F;var&#x2F;run –&gt; &#x2F;run</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><ul>
<li>目录树特性<ul>
<li>目录树起始点为根目录(&#x2F;，root)</li>
<li>目录不仅可以使用本地分区的文件系统，也可以使用网络上的文件系统，eg：NFS</li>
<li>各文件路径独一无二</li>
</ul>
</li>
<li>大致目录架构(重要的是绿色的)<br><img src="/2022/03/14/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/1240-164725727988897.png"></li>
</ul>
</li>
<li><h2 id="CentOS的观察"><a href="#CentOS的观察" class="headerlink" title="CentOS的观察"></a>CentOS的观察</h2><ul>
<li>除FHS外，还有一个LSB(Linux standard Base)可依循</li>
<li>通过uname检查Linux核心与操作系统位版本<br>&#96;&#96;&#96;<ul>
<li>uname -r:查看核心版本</li>
<li>uname -m:查看操作系统的位版本</li>
<li>lsb_release -a：比较细致，需安装</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>重点回顾<ul>
<li>Linux 的每个文件中，可分别给予使用者、群组与其他人三种身份个别的 rwx 权限；</li>
<li>每个账号都可以有多个群组的支持；</li>
<li>利用 ls -l 显示的文件属性中，第一个字段是文件的权限，共有十个位，第一个位是文件类型， 接下来三个为一组共三组，为使用者、群组、其他人的权限，权限有 r,w,x 三种；</li>
<li>如果档名之前多一个『. 』，则代表这个文件为『隐藏档』；</li>
<li>若需要 root 的权限时，可以使用 su - 这个指令来切换身份。处理完毕则使用 exit 离开 su 的指令环境。</li>
<li>更改文件的群组支持可用 chgrp，修改文件的拥有者可用 chown，修改文件的权限可用 chmod</li>
<li>chmod 修改权限的方法有两种，分别是符号法与数字法，数字法中 r,w,x 分数为 4,2,1；</li>
<li>对文件来讲，权限的效能为：<ol>
<li>r：可读取此一文件的实际内容，如读取文本文件的文字内容等；</li>
<li>w：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)；</li>
<li>x：该文件具有可以被系统执行的权限。</li>
</ol>
</li>
<li>对目录来说，权限的效能为：<ol>
<li>r (read contents in directory)</li>
<li>w (modify contents of directory)</li>
<li>x (access directory)</li>
</ol>
</li>
<li>要开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限，但 w 权限不可随便给；</li>
<li>能否读取到某个文件内容，跟该文件所在的目录权限也有关系 (目录至少需要有 x 的权限)。</li>
<li>Linux 档名的限制为：单一文件或目录的最大容许文件名为 255 个英文字符或 128 个汉字字符；</li>
<li>根据 FHS 的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下</li>
<li>FHS 订定出来的四种目录特色为： shareable, unshareable, static, variable 等四类；</li>
<li>FHS 所定义的三层主目录为： &#x2F;, &#x2F;var, &#x2F;usr 三层而已；</li>
<li>绝对路径文件名为从根目录 &#x2F; 开始写起，否则都是相对路径的文件名。</li>
</ul>
</li>
</ul>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    'If only I had ... ' If you ever have that thought ricocheting in your brain, it will hurt a lot.---Larry Smith《Why you will fail to have a great career》
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2022/05/07/3-Using-the-help-system/">3 Using the help system</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/05/07/%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5/">博客记录及常用链接</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/04/10/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0BASH/">第十章、认识和学习BASH</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/03/31/%E5%85%B3%E4%BA%8ESSH%E6%8C%87%E7%BA%B9%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/">关于SSH指纹的一点记录</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/Professor-Messer%E2%80%99s-CompTIA-N10-008-Network-Course-notes/">Professor Messer’s CompTI</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Learn-Windows-PowerShell-in-a-Month-of-Lunches-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Learn Windows PowerShell </a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Precious/">Precious</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Triffle/">Triffle</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/March13th">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:sheldor13th@gmail.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>