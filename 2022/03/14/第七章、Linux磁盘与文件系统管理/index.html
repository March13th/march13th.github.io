<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="March 13th">





<title>第七章、Linux磁盘与文件系统管理 | March 13th&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">March 13th&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">March 13th&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">第七章、Linux磁盘与文件系统管理</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">March 13th</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 14, 2022&nbsp;&nbsp;0:20:07</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">鸟哥的Linux私房菜-读书笔记</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <ul>
<li>认识Linux文件系统<ul>
<li>磁盘组成及分区复习(正好给自己提几个问题)<ul>
<li>什么是扇区，有哪两种格式<ul>
<li>扇区(Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512bytes 与 4K 两种格式；</li>
</ul>
</li>
<li>什么是磁柱<ul>
<li>将扇区组成一个圆，那就是磁柱(Cylinder)；</li>
</ul>
</li>
<li>磁盘分区表的两种格式<ul>
<li>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</li>
</ul>
</li>
<li>MBR第一个扇区由什么组成呢<ul>
<li>MBR 分区表中，第一个扇区最重要，里面有： (1)主要开机区(Master boot record, MBR)及分区表(partition<br>table)， 其中 MBR 占有 446 bytes，而 partition table 则占有 64 bytes。</li>
</ul>
</li>
<li>实体磁盘的文件名是什么<ul>
<li>&#x2F;dev&#x2F;sd[a-p][1-128]</li>
</ul>
</li>
<li>虚拟磁盘的文件名是什么<ul>
<li>&#x2F;dev&#x2F;vd[a-d][1-128]</li>
</ul>
</li>
</ul>
</li>
<li>文件系统特性<ul>
<li><strong>什么是格式化</strong>，(我以前只是觉得是清空哈哈哈哈，还真没想过)，每种操作系统所设定的文件属性和权限并不相同，格式化分区槽是为了让它变成系统能够使用的”文件系统格式”</li>
<li><strong>文件系统</strong>通常将权限和属性放到inode中，实际数据放到data block区块中，另外有一个超级区块(superblock)会记录整个文件系统的整体信息(inode与block的总量呀，使用量呀，剩下多少呀，听起来像一个管家哈哈哈哈)</li>
<li><strong>inode、block、superblock的简要概述</strong><ul>
<li>superblock：记录此 filesystem 的整体信息(inode&#x2F;block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息)</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录文件数据所在的block号码</li>
<li>block：实际记录文件的内容，如果是很大的文件就多占一些block啦</li>
</ul>
</li>
<li><strong>关于碎片整理</strong><ul>
<li>需要碎片整理是因为写入的block过于离散啦，想想磁盘机械手臂的磁盘读取头来来回回的我都觉得累，碎片整理就是将同一个文件的block整理到一起，那么数据的读取就变得容易，但是Ext2是<strong>索引式文件系统</strong>(一下子将inode中的block号码对应的block全读出来，是不是有点像散列表哈哈哈)，不太需要碎片整理啦，但是如果是以前的老式u盘呢，例如FAT格式(这里读取block是需要一个一个读取的，感觉像链表)，就需要碎片整理了</li>
</ul>
</li>
</ul>
</li>
<li>Linux的Ext2文件系统(inode)</li>
</ul>
<ul>
<li>文件系统一开始就将inode与block规划好了，除非重新格式化or利用resize2fs等指令变更文件系统大小，否则inode和block就固定不再变动啦<ul>
<li>关于区块群组<ul>
<li>如果文件系统太大啦，那么那么夺得inode与block都放在一起也不好管理，于是Ext2文件系统在格式化的时候会区分为多个区块群组，而每个群组都有独立的inode、block、superblock系统<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240.png"></li>
<li>接上图，文件系统最前面有一个启动扇区(boot sector)可安装开机管理程序，所以我们才能由多重引导呀！</li>
</ul>
</li>
<li>data block<ul>
<li>Ext2 文件系统中所支持的 block 大小有 1K, 2K 及<br>4K 三种而已<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240-1647257365181100.png"></li>
<li>上图非绝对，某些应用程序捕捉不到辣么大的文件</li>
<li>关于<strong>Ext2文件系统block的限制</strong><ol>
<li>原则上， block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)</li>
<li>每个 block 内最多只能够放置一个文件的数据</li>
<li>如果文件大于 block 的大小，则一个文件会占用多个 block 数量</li>
<li>若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)</li>
<li>现在磁盘都太大啦，4k就好，知道原理就行</li>
</ol>
</li>
</ul>
</li>
<li>inode table<ul>
<li><strong>inode记录的文件数据</strong>至少有：<ol>
<li>该文件的存取模式(read&#x2F;write&#x2F;excute)；</li>
<li>该文件的拥有者与群组(owner&#x2F;group)；</li>
<li>该文件的容量；</li>
<li>该文件建立或状态改变的时间(ctime)；</li>
<li>最近一次的读取时间(atime)；</li>
<li>最近修改的时间(mtime)；</li>
<li>定义文件特性(flag)，如 SetUID…；</li>
<li>该文件真正内容的指向 (pointer)；</li>
</ol>
</li>
<li><strong>关于inode的特色</strong><ol>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)</li>
<li>每个文件都仅会占用一个inode</li>
<li>文件系统能够建立的文件数量与inode的数量有关</li>
<li>系统读取文件需先找到inode，先分析inode所记录的权限与用户是否符合，如果符合才能够开始读取block内容</li>
</ol>
</li>
<li><strong>关于inode的12个直接、一个间接、一个双间接和一个三间接</strong><ul>
<li>如果文件很大呢，inode记录一个block号码要花费4byte，根本记录不下那么多block号码<br><img src="/2022/03/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1240-1647257368613102.png"></li>
<li>直接就是直接指向block号码的对照</li>
<li>间接就是再拿一个block当作记录block号码的记录区</li>
<li>双间接就是使用第一个block来记录block号码</li>
<li>三间接就是使用第二个block记录block号码</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>假如block大小为1k，inode能指定多少block呢<ul>
<li>12个直接：12*1K&#x3D;12K</li>
<li>间接：256*1K&#x3D;256K</li>
<li>双间接：256<em>256</em>1K&#x3D;2562K</li>
<li>三间接： 256<em>256</em>256*1K&#x3D;2563K</li>
<li>总额&#x3D;12 + 256 + 256<em>256 + 256</em>256*256 (K) &#x3D; 16GB</li>
<li>注意2k与4k block不能这么计算，因为会受到Ext2文件系统本身的限制</li>
</ul>
</li>
</ul>
<ul>
<li><p>superblock</p>
<ul>
<li><strong>superblock记录的主要信息</strong><ol>
<li>block与inode的总量</li>
<li>未使用与已使用的inode和block数量</li>
<li>block与inode的大小(block 为 1, 2, 4K， inode 为 128bytes 或 256bytes)</li>
<li>filesystem的挂载时间，最近一次写入数据的时间，最近一次检查磁盘(fsck)的时间等文件系统相关信息</li>
<li>一个valid bit数值，如果这个文件系统已经被挂载，valid bit为0，否则valid bit为1</li>
<li><strong>注意</strong>：除了第一个block group含有superblock之外，后面的block group不一定含有superblock，如果有的话呢，主要是作为第一个block group内superblock的备份，用于救援</li>
</ol>
</li>
<li><strong>Filesystem Description(文件系统描述谁说明)</strong><ol>
<li>该区段描述每个block group的开始和结束block号码，以及每个区段(superblock、bitmap、inodemap、data block)分别介于哪一个block号码之间</li>
</ol>
</li>
</ul>
</li>
<li><p>block bitmap(区块对照表)**</p>
<ul>
<li><strong>block bitmap记录的主要信息</strong><ol>
<li>记录哪些block是空的</li>
<li>再删除某些文件时，文件原本占用的block号码需要释放，block bitmap中相应的block号码标志就会被修改为”空闲”</li>
</ol>
</li>
</ul>
</li>
<li><p>查看文件的inode</p>
<ul>
<li>使用ls -i name查看inode，另外可以使用filefrag -v name查看文件分布在哪些block中</li>
</ul>
</li>
<li><p>dumpe2fs：查询Ext家族superblock信息的指令**</p>
<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1. dumpe2fs [-bh] 装置文件名</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
<ol>
<li>-b ：列出保留为坏轨的部分(用不到 )</li>
<li>-h ： 仅列出 superblock 的数据，不会列出其他的区段内容。</li>
</ol>
</li>
<li>blkid:显示目前系统被格式化的装置</li>
<li>dumpe2fs的部分字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">        1. Filesystem volume name：文件系统的名称</span><br><span class="line">        2. Last mounted on：上一次挂载的目录位置</span><br><span class="line">        3. Filesystem UUID：Linux对装置的定义码</span><br><span class="line">        4. Filesystem features：文件系统的特征数据</span><br><span class="line">        5. Default mount options：预设在挂载时会主动加上的挂载参数</span><br><span class="line">        6. Filesystem state：这块系统的文件的状态，clean是没问题的意思</span><br><span class="line">        7. Inode count：inode的总数</span><br><span class="line">        8. Block count：block的总数</span><br><span class="line">        9. Reserved block count：保留的block总数</span><br><span class="line">        10. Free blocks：空闲的block可用数量</span><br><span class="line">        11 Free inodes：空闲的inode可用数量</span><br><span class="line">        12. Block size：单个block的容量大小</span><br><span class="line">        13. inode size：inode的容量大小</span><br><span class="line">        14. Journal size：日志式数据的可供记录总量</span><br><span class="line">        15. Group 0：第一块block group位置</span><br><span class="line">        16. Primary superblock at 0, Group descriptors at 1-1：主要 superblock 的所在</span><br><span class="line">        17. Inode table at 161-672 (+161)：inode table的所在</span><br><span class="line">        18. Free blocks：剩余的容量有多少</span><br><span class="line">  - 与目录树的关系</span><br><span class="line">    + 目录</span><br><span class="line">      * 当我们在linux的文件系统建立一个目录时，系统会分配一个inode和至少一块block给该目录，inode记录该目录的权限、属性and分配到的block号码，block记录在这个目录下的文件名和该文件名占用的inode号数据[要记得这只是个目录呀]</span><br><span class="line">      * 当目录下的文件数过多导致一个block无法容纳所有文件名+inode对照号码时，Linux会给于该目录多一个block来记录相关的数据</span><br><span class="line">    + 文件</span><br><span class="line">      * 当我们在Linux的ext2建立一个一般文件时，ext2分配一个inode与相匹配与文件大小的block给该文件，[记得如果文件很大时候我们还有inode的12个直接、一个间接、一个双间接和一个三间接帮忙]</span><br><span class="line">    + 目录树读取</span><br><span class="line">      * eg：读取/etc/passwd的过程</span><br><span class="line">        1. / 的 inode：</span><br><span class="line">            透过挂载点的信息找到根目录 inode，且 inode 规范的权限让我们可以读取该 block的内容(有 r 与 x)；</span><br><span class="line">        2. / 的 block：</span><br><span class="line">            取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码；</span><br><span class="line">        3. etc/ 的 inode：</span><br><span class="line">            读取 etc的inode号码得知用户具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容；</span><br><span class="line">        4. etc/ 的 block：</span><br><span class="line">            取得 block 号码，并找到该内容有 passwd 文件的 inode 号码；</span><br><span class="line">        5. passwd 的 inode：</span><br><span class="line">            读取passwd的inode号码得知用户具有  r 的权限，因此可以读取 passwd 的 block 内容；</span><br><span class="line">        6. passwd 的 block：</span><br><span class="line">            将该 block 内容的数据读出来。</span><br><span class="line">    + filesystem 大小与磁盘读取效能</span><br><span class="line">      * 文件系统过大可能会有文件数据离散的问题发生，合理规划分区</span><br><span class="line">  - EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能</span><br><span class="line">    + 新增一个文件时文件系统的行为</span><br><span class="line">      1. 确定新增文件的目录是不是有相应权限</span><br><span class="line">      2. 根据inode bitmap找到没有使用的inode号码，将新文件的权限/属性写入</span><br><span class="line">      3. 根据block bitmap找到未使用的block号码，将实际数据写入block，并更新inode的block指向</span><br><span class="line">      4. 将刚刚写入的inode与block数据同步至inode  bitmap与block bitmap，并更新superblock的内容</span><br><span class="line">    + 数据存放区域与中介数据 </span><br><span class="line">      1. 将inode table与data block称为数据存放区域</span><br><span class="line">      2. 将其他eg：superblock、block bitmap与inode bitmap等区段称为metadata(因为superblock、block bitmap与inode bitmap数据经常变动，无论新增、删除还是修改都会影响这几个区段的数据，所以就叫中介数据啦)</span><br><span class="line">    + 数据不一致(inconsistent)状态</span><br><span class="line">      1. 写入inode table与data block数据之后，嘣！停电了！系统不知道为啥断了！metadata的内容与实际数据存放区不一致</span><br><span class="line">      2. Ext2中，如果有此情况，系统重新启动后会由superblock当中的valid bit与filesystem state等状态判断是否强行进行数据一致性检查(费事费力，要针对metadata区域与实际数据存放区进行对比，要搜寻整个filesystem，于是引出了日志式文件系统)</span><br><span class="line">    + 日志式文件系统(journaling filesystem)</span><br><span class="line">      * 简化了的一直性检查的步骤</span><br><span class="line">        1. 预备：当系统要写入一个文件，在日志记录区块中记录某个文件准备要写入的信息</span><br><span class="line">        2. 实际写入：写入文件的权限and数据，更metadata的数据</span><br><span class="line">        3. 结束：完成数据与metadata的更新</span><br><span class="line">      * 这样做的好处在于有问题检查日志记录区块就好了，不用针对整块filesystem检查</span><br><span class="line">    + Linux文件系统的运作</span><br><span class="line">      * 关于异步处理(asynchronously)的方式</span><br><span class="line">        系统加载一个文件到内存后，如果文件没有修改过，那么内存区段的文件数据就会设定为干净(clean)的,但是如果内存中的文件被修改过，此时内存中的数据就会被设定为脏的(dirty)，此时所有的动作都在内存中进行，不写入到磁盘，然后系统不定时的将内存中设定为dirty的数据写回磁盘，以保持磁盘和内存数据一致性</span><br><span class="line">      * 关于Linux文件系统与内存的关系</span><br><span class="line">        1. 系统将常用的文件数据放置到主存储器的缓冲区，用来加速文件系统的读写</span><br><span class="line">        2. 所以Linux的物理内存最后都会被用光，这是正常滴，为了加速系统效能</span><br><span class="line">        3. 可以使用sync来强迫内存中dirty的文件回写到磁盘</span><br><span class="line">        4. 关机指令会主动呼叫sync</span><br><span class="line">        5. 非正常系统中断，由于数据未回写到磁盘，重新启动可能要花费时间进行磁盘检验，还有可能导致文件系统的损毁(不是磁盘坏了...)</span><br><span class="line">    + 挂载点的意义(mount point)</span><br><span class="line">      * 挂载点一定时目录,该目录未进入该文件系统的入口</span><br><span class="line">      * **这里要重点重重点记录一下了!!!**这里我本来一直没搞清楚为什么/，/home，/boot这三个目录的inode的号码都是一样的，而且为什么说/，/home，/boot是三个不同的文件系统</span><br><span class="line">        _**因为他们都挂载在根目录啊，目录是目录，挂载只是挂在树上的果子而已，谁或三个果子不能长在一个枝桠上，剩下的事交给目录inode指向的block，而/，/home，/boot的文件属性并不相同，挂载点也不相同，所以自然是三个不同的文件系统**_</span><br><span class="line">      * 为什么/，/.，/..是一样的东西呢，可以看一看，文件属性相同，还指向一个inode，还都是一个挂载点，当然是一个东西[官方一点说，同一个filesystem的某个inode只会对应到一个文件内容，毕竟一个文件占用一个inode嘛]</span><br><span class="line">  - 其他 Linux 支持的文件系统与 VFS</span><br><span class="line">    + 常见的支持的日志式文件系统</span><br><span class="line">      *  传统文件系统： ext2 / minix / MS-DOS / FAT (用 vfat 模块) / iso9660 (光盘)等等</span><br><span class="line">      *  日志式文件系统： ext3 /ext4 / ReiserFS / Windows&#x27; NTFS / IBM&#x27;s JFS / SGI&#x27;s XFS / ZFS</span><br><span class="line">      *  网络文件系统： NFS / SMBFS</span><br><span class="line">    + 查看Linux支持的文件系统</span><br><span class="line">      ```ls -l /lib/modules/$(uname -r)/kernel/fs```</span><br><span class="line">    + 查看目前已加载到内存中支持的文件系统</span><br><span class="line">      ```cat /proc/filesystems```</span><br><span class="line">    + Linux VFS(virtual filesystem switch)</span><br><span class="line">      * 整个linux系统都是通过名为vfs的核心功能来读取filesystem的，所以我们才无需知道每个partition是什么，vfs主动帮我们做好读取的工作</span><br><span class="line">    + vfs简略图</span><br><span class="line">         ![](1240-1647257373446104.png)</span><br><span class="line">  - XFS 文件系统简介</span><br><span class="line">    + EXT 家族： 支持度最广，格式化超慢</span><br><span class="line">      * ext家族采用的是预先规划处所有的inode/block/metadata等数据，但是目前磁盘容量愈来愈大，传统MBR被GPT取代，格式化的时候预先分配inode和block要耗费大量时间</span><br><span class="line">    + XFS 文件系统的配置</span><br><span class="line">      * xfs主要规划为三个部分，一个资料区 (data section)、一个文件系统活动登录区 (log section)以及一个实时运作区 (realtime section)    </span><br><span class="line">        1. 资料区(data section)</span><br><span class="line">          * 与ext家族一样包括 inode/data block/superblock 等数据</span><br><span class="line">          * 与ext家族类似，data section分为多个储存区群组(allocation groups)，每个储存区群组包含(1)整个文件系</span><br><span class="line">        统的 superblock、 (2)剩余空间的管理机制、 (3)inode 的分配与追踪。</span><br><span class="line">          * inode与block在系统需用时动态生成</span><br><span class="line">          * 与ext家族不同之处，xfs的block与inode哟多种不同的容量可设定，block[512bytes ~ 64K,最高4k，不然linux核心不给挂载没法用]，inode[256bytes ~2M，256bytes的默认值即可]</span><br><span class="line">        2. 文件系统活动登录区(log section)</span><br><span class="line">          * 主要用来记录文件系统的变化，直至文件的变化完整的写入到数据区，该文件的该笔记录才会终结，文件系统意外中断后系统会依此登录区进行检验，来快速的修复文件系统</span><br><span class="line">          * 可指定外部的磁盘作为xfs的日志区块(因为读写频繁，可指定ssd)</span><br><span class="line">        3. 实时运作区(realtime section)</span><br><span class="line">          * 文件建立时，xfs在这一区段找一个或书个extent区块用来将文件放置在这个区块内，等到分配完毕，再写入data section的inode与block中</span><br><span class="line">          * 这个extent区块大小在格式化时要先指定[4K~1G]，默认即可，不要乱动[会影响到实际磁盘的效能]</span><br><span class="line">    + XFS文件系统的描述数据观察</span><br><span class="line">      * ```xfs_info 挂载点/装置文件名```</span><br><span class="line">      ![](1240-1647257376074106.png)</span><br><span class="line">      * 第一行，isize=inode的容量，agcount=储存区群组的个数，agsize=每个储存区群组具有65536个block，文件系统容量=4*65536*4k*(第四行bsize=4096=4k)</span><br><span class="line">      * 第二行，sectsz=逻辑扇区(sector)的容量</span><br><span class="line">      * 第四行，bsize=block的容量</span><br><span class="line">      * 第五行，sunit与swidth与磁盘阵列的stripe相关性较高</span><br><span class="line">      * 第七行，internal指的是这个登录区的位置在文件系统内，而非外部设备</span><br><span class="line">      * 第九行，realtime=none表示没有使用，extent容量=4k</span><br><span class="line">---</span><br><span class="line">- 文件系统的简单操作</span><br><span class="line">  - 磁盘与目录的容量</span><br><span class="line">    + df</span><br><span class="line">      - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>df [-ahikHTm] [目录或文件名]</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    1. -a：列出所有文件系统，包括特有的/proc等文件系统</span><br><span class="line">    2. -k：以kbytes的容量显示</span><br><span class="line">    3. -m：以mbytes的容量显示</span><br><span class="line">    4. -h：以较易阅读的格式显示(G,M,K)</span><br><span class="line">    5. -H：以m=1000k取代m=1024k的方式</span><br><span class="line">    6. -T：连同partition的filesystem名称(eg：xfs)也列出来</span><br><span class="line">    7. -i：不用磁盘容量，而以inode的数量来显示   </span><br><span class="line">  - 字段含义</span><br><span class="line">    1. filesystem：代表文件系统是在哪个partition</span><br><span class="line">    2. 1k-blocks：底下的数字单位是1kb</span><br><span class="line">    3. used：使用掉的硬盘空间</span><br><span class="line">    4. available：剩下的磁盘空间大小</span><br><span class="line">    5. use%：磁盘使用率</span><br><span class="line">    6. mounted on：挂载点</span><br><span class="line">  - 有个/dev/shm的目录是内存虚拟出来的磁盘空间哈，通常是总物理内存的一半</span><br><span class="line">+ du</span><br><span class="line">  - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>du [-ahskm] 文件或目录名称</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      1. -a列出所有的目录与文件容量</span><br><span class="line">      2. -h：同df</span><br><span class="line">      3. -s：列出总量，而不列出每个目录的占用容量</span><br><span class="line">      4. -S：不包括子目录的统计，与-s有差别</span><br><span class="line">      5. -k，-m：同上</span><br><span class="line">    - 直接输入du不加选项，du会分析当前目录的文件与目录所占用的磁盘空间，实际显示时仅会显示目录容量(不含文件)</span><br><span class="line">- 实体链接与符号链接</span><br><span class="line">  + Hard link(实体链接、硬链接or实际链接)</span><br><span class="line">    - 有没有可能多个档名对应到同一个inode？**hard link就是在某个目录下新增一笔档名链接到某个inode号码的关联记录**</span><br><span class="line">    - 建立实体链接的指令</span><br><span class="line">      `ln 目标文件名 将建立实体链接的文件名`</span><br><span class="line">    - 示意图</span><br><span class="line">      ![](1240-1647257378728108.png)</span><br><span class="line"></span><br><span class="line">    - 建立实体链接的好处</span><br><span class="line">      * 安全：将任何一个文件删除后，inode与block都依然存在，可通过另一个档名来读取到正确的文件数据</span><br><span class="line">    - 有没有可能hard link改变block呢，有，新增数据正好将目录的block填满时则需要再加一个block来记录时</span><br><span class="line">    - hard link的限制</span><br><span class="line">      * 不能跨filesystem</span><br><span class="line">      * 不能link目录</span><br><span class="line">  + Symbolic link(符号链接)</span><br><span class="line">    - symbolic link就是建立一个独立的文件，当数据读取时这个文件会指向他link的文件的档名，当源档被删除后，符号链接的文件将找不到原始的档名</span><br><span class="line">    - 建立符号链接的指令</span><br><span class="line">      `ln -s 目标文件名 将建立符号链接的文件名`</span><br><span class="line">    - 连结档的重要内容就是他会写上目标文件的文件名(ll可以看到连结档的的大小其实就是目标文件名的路径)</span><br><span class="line">    - 示意图</span><br><span class="line">      ![](1240-1647257380745110.png)</span><br><span class="line">  + ln</span><br><span class="line">    - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>ln [-sf] 来源文件 目标文件</li>
</ol>
</li>
<li>选项与参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  -s:如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link</span><br><span class="line">  -f:如果目标文件存在时，就主动的将目标文件直接移除后再建立</span><br><span class="line">- eg</span><br></pre></td></tr></table></figure>
cd &#x2F;tmp;cp -a &#x2F;etc&#x2F;passwd<br>du -sb;df -i .(计算&#x2F;tmp下有多少个bytes的容量，使用了多少inode)<br>ln passwd passwd_hd(实体链接)<br>du -sb;df -i .(观察)<br>ln -s passwd passwd_so(符号链接)<br>du -sb;df -i .(观察)<br>ll -i passwd*(观察)</li>
<li>关于目录的link数量<ul>
<li>新建一个目录，会有三样东西，目录本身，“.”，”..”，”.”指向目录本身，”..”指向上层目录，so…<strong>新的目录link数为2，上层目录的link数增加1</strong></li>
</ul>
</li>
<li>一点点补充：简单点记录，软链接就是我在我的block存了你的inode，硬链接就是我和你共用一个inode</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>磁盘的分区、格式化、检验与挂载<ul>
<li>新增一颗磁盘时的动作<ol>
<li>对磁盘进行分区，以建立可用的 partition</li>
<li>对该 partition 进行格式化 (format)，以建立系统可用的 filesystem</li>
<li>若仔细一点，则对刚刚建立好的 filesystem 进行检验</li>
<li>在 Linux 系统上，需要建立挂载点 (亦即是目录)，并将他挂载上来</li>
</ol>
</li>
</ul>
<ul>
<li>观察磁盘分区状态<ul>
<li>lsblk 列出系统上的所有磁盘列表<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  1.   lsblk [-dfimpt] [device]</span><br><span class="line">- 选项与参数</span><br></pre></td></tr></table></figure>
-d ： 仅列出磁盘本身，并不会列出该磁盘的分区数据<br>-f ：同时列出该磁盘内的文件系统名称<br>-i ：使用 ASCII 的方式输出，不使用复杂的编码<br>-m ：同时输出该装置在 &#x2F;dev 底下的权限数据 (rwx 的数据)<br>-p ：列出该装置的完整文件名<br>-t ：列出该磁盘装置的详细数据，包括磁盘队列机制、 预读写的数据量大小等</li>
<li>一些字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      NAME:装置的文件名(省略/dev等前导目录)</span><br><span class="line">      MAJ:MIN:主要:次要装置代码(核心认识的装置都是透过这两个代码熟悉的)</span><br><span class="line">      RM:是否为可卸除装置(usb、光盘...etc)</span><br><span class="line">      SIZE:容量</span><br><span class="line">      RO:是否为只读装置</span><br><span class="line">      TYPE:是磁盘(disk)，分区(partition)还是只读存储器(rom)等</span><br><span class="line">      MOUNTPOINT:挂载点</span><br><span class="line">    - eg</span><br><span class="line">      1. 列出/dev/sda装置内所有数据的完整文件名</span><br><span class="line">          ```lsblk -ip /dev/sda```</span><br><span class="line">      2. 列出装置的UUID参数</span><br><span class="line">          **UUID：全局单一标识符，Linux将系统内所有的装置都给予一个独一无二的标识符，可用来挂载or使用**</span><br><span class="line">          ```blkid```</span><br><span class="line">      3. parted列出磁盘的分区表类型与分区信息</span><br><span class="line">          ```parted device_name print```</span><br><span class="line">          几个字段</span><br><span class="line">          Model:磁盘的模块名(厂商</span><br><span class="line">          Disk /dev/sda:磁盘的总容量</span><br><span class="line">          Partition Table:分区表格式(MBR/GPT)</span><br><span class="line">- 磁盘分区:gdisk/fdisk</span><br><span class="line">  + __MBR分区使用fdisk分区，GPT分区使用gdisk分区</span><br><span class="line">  + gdisk(不需要背)</span><br><span class="line">    * gdisk 装置名称</span><br><span class="line">      eg：</span><br></pre></td></tr></table></figure>
gdisk &#x2F;dev&#x2F;sda<br>几个常用的指令<br>d delete a partition  删除一个分区<br>n add a new partition  增加一个分区<br>p print the partition table  印出分区表 (常用)<br>q quit without saving changes  不储存分区就直接离开 gdisk<br>w write table to disk and exit  储存分区操作后离开 gdisk</li>
</ul>
<ul>
<li>使用gdisk不要背，？之后就全都可以看到(可以随便玩，别按w，按q就行了)</li>
<li>p列出目前磁盘分区表信息后的几个字段<ol>
<li>Number：分区表编号，1指的是&#x2F;dev&#x2F;sda1</li>
<li>Start(sector)：每一个分区槽开始扇区号码位置</li>
<li>End(sector)：每一个分区的结束扇区号码位置，与 start 之间可以算出分区槽的总容量</li>
<li>Size：分区槽容量</li>
<li>Code：分区槽内可能的文件系统类型，linux为8300，swap为8200(只是一个提示，不见得真的代表分区槽内的文件系统)</li>
<li>Name：文件系统的名称</li>
</ol>
</li>
<li><strong>几点重要的结论</strong><ol>
<li><strong>可以看到最大扇区数及目前使用到的扇区数，可以进行额外的分区</strong></li>
<li><strong>新分区通常选用上一个分区的结束扇区号码+1作为起始扇区号码</strong></li>
<li>gdisk只有root可以执行，使用的装置文件名eg:&#x2F;dev&#x2F;sda，而不要使用&#x2F;dev&#x2F;sda1,因为我们是对整个磁盘进行分区而不是某个分区进行分区</li>
</ol>
</li>
<li>用gdisk新增分区槽(下面是假设需求)<br>     1GB 的 xfs 文件系统 (Linux)<br>     1GB 的 vfat 文件系统 (Windows)<br>     0.5GB 的 swap (Linux swap)<br>     S1：这里只需要注意Last sector不要使用默认值即可，使用+1G的方式，gdisk会根据填写的数值直接计算出最接近该容量的扇区数，分区后可按p查看结果，无误则w写入(btw关于文件系统的id[Linux一般是8200&#x2F;8300&#x2F;8e00，windows几乎都用0700]，可按L查看)<br>     S2：cat &#x2F;proc&#x2F;partitions，发现没有新的分区，是因为linux还在使用磁盘，分区表还未更新，两种解决方法，重启or partprobe指令</li>
<li>partprobe更新Linux核心的分区表信息<figure class="highlight plaintext"><figcaption><span>[-s]```不加-s屏幕就不会出现信息，建议加</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      then，使用lsblk 装置名查看实际的磁盘分区状态，cat /proc/partitions查看核心的分区记录，都可以看到最新的分区</span><br><span class="line">    * 用gdisk删除一个分区槽</span><br><span class="line">      直接在选项中选d并选择分区号即可，**注意要去处理一个正在使用的分区槽，必须要先卸除**</span><br><span class="line">  + fdisk</span><br><span class="line">    * 输入m后可看到指令介绍，与gdisk没差啦</span><br><span class="line">- 磁盘格式化(建立文件系统)</span><br><span class="line">  + XFS文件系统 mkfs.xfs</span><br><span class="line">    - 语法</span><br></pre></td></tr></table></figure>
<ol>
<li>mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f]  [-r parms] 装置名称</li>
</ol>
</li>
</ul>
<ul>
<li>选项与参数<br>关于单位：底下只要谈到『数值』 时， 没有加单位则为 bytes 值，可以用 k,m,g,t,p (小写)等来解释<br>比较特殊的是 s 这个单位，它指的是 sector 的『个数』喔！</li>
</ul>
<p>-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！<br>-d ：后面接的是重要的 data section 的相关参数值，主要的值有：<br>agcount&#x3D;数值 ： 设定需要几个储存群组的意思(AG)，通常与 CPU 有关<br>agsize&#x3D;数值 ：每个 AG 设定为多少容量的意思，通常 agcount&#x2F;agsize 只选一个设定即可</p>
</li>
<li>EXT4文件系统 mkfs.ext4  <ul>
<li>用法一样，更多直接mkfs tab tab就可以看见</li>
</ul>
</li>
</ul>
</li>
<li>文件系统检验<ul>
<li>xfs_repair处理XFS文件系统<ul>
<li>使用xfs_repair [-fnd] &#x2F;dev&#x2F;sda1,-f代表后面是文件而不是实体设备，-n代表单纯检查而已，-d代表对根目录进行检查和修复，danger，danger，哈哈哈哈,修复挂载</li>
</ul>
</li>
<li>fsck.ext4处理EXT4文件系统<ul>
<li>fsck tab tab可以看见很多针对不同文件系统的修复</li>
<li>选项就记个-p：自动回复ｙ来继续进行修复动作，和一个-b：利用文件系统内备份的superblock尝试救援</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Recover：<br>解除挂载时，提示devise is busy，可以使用fuser -mv 挂载点查看是哪个进程正在占用<br>tune2fs,修改卷标，最大挂载次数等等，同时e2label 设备名 卷标也可以修改<br>注意修改分区后一定要记得partprobe，然后格式化分区，swap分区需要使用swapon 设备名称激活，关闭使用swapoff【cat &#x2F;proc&#x2F;swaps 】【修改卷标的意义在哪里呢：接下来挂载时可以直接使用 mount LABEL&#x3D;卷标名称 挂载点进行挂载，注意如果是挂载镜像时，类型要写iso9660，权限是defaults,loop】<br>还可以怎样创建一个swap分区呢，dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file bs&#x3D;1M count&#x3D;100,这样就创建了一个100M的file文件，接着格式化：mkswap file，然后swapon file激活，紧接着在cat proc&#x2F;swaps的时候就可以看到新的swap分区了，值得注意的是swap分区使用的是file占用的空间而不是其本身，然后可以给他设置开机自动挂载</p>
<ul>
<li>文件系统的简单操作<ul>
<li>磁盘与目录的容量：df显示所有已挂载文件系统及其容量，du显示文件、目录的容量<br> 常用：df -hT（h即以方便读的容量显示，T会显示出文件系统的类型）,du -sh（s即查看总大小）</li>
<li>ln创建链接文件<br> 常用：ln -sf 目标文件名 将建立链接的文件名（s是符号链接，不加就是硬链接，f是删除已存在的链接文件）</li>
</ul>
</li>
</ul>
<p>日志文件系统<br>各个blockgroup的基本结构为superblock+文件系统描述信息+blosk位图+inode位图+inode表+block，所以ext3–&gt;ext2系统多了的日志记录功能在于文件进行写入操作时记录日志，避免某个步骤中断导致的元数据与实际数据不一致</p>
<p>VFS（虚拟文件系统）<br>linux中多种文件系统，eg ext2、ext3、vfa…etc，那么VFS存在的意义是什么呢，我们的程序可以不关注实际的文件系统是什么，</p>
<p>fdisk<br>查看分区：-l:display partitions and exit,单独查看某一分区就直接fdisk -l &#x2F;dev&#x2F;sda1<br>分区：fidsk &#x2F;dev&#x2F;sda(注意是对硬盘进行分区而不是对分区进行分区，不要写为fdisk dev&#x2F;sda1)<br>为什么一个硬盘只能划分 主分区+扩展分区&lt;&#x3D;4个，因为一个硬盘的MBR区一共512字节，512字节&#x3D;446(引导程序)+64(分区表)+2(结束符号)，但是标记一个分区需要16字节，所以要是想划分多个分区就在扩展分区里划分逻辑分区吧<br>修改分区后的操作：partprobe更新分区表–&gt;mkfs格式化分区–&gt;挂载</p>
<p>挂载<br>挂载：标准格式：mount -o 选项 -t 文件系统，一般使用的就是mount 需挂载的设备 挂载点；解除挂载：umount 外部设备or挂载点；重新挂载eg：mount -o remount &#x2F;mnt（挂载）;几种选项，rw，ro，noexec，exec；解除挂载是可以使用fuser -mv 设备名称查看正在使用挂载点的程序<br>磁盘检验：fsck &#x2F;dev&#x2F;sda5(-f：强制自检；-C 显示过程)，badblocks  dev&#x2F;sda3<br>开机自动挂载：&#x2F;etc&#x2F;fstab 写入，blkid可以显示出所需要的uuid，同时注意1.文件系统不要写错了；2后面的两位数字，第一个为是否启动备份，第二个为是否使用fsck自检<br>磁盘参数修改：tune2fs<br>特殊设备挂载：镜像文件不可路就挂载使用，eg：mount -o loop 镜像 挂载点</p>
<p>内存交换空间（swap）的构建<br>使用物理分区构建：就是常规的fdisk创建一个分区，记得了类型选对，格式化（mkswap），激活（swapon）<br>使用文件构建：dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file bs&#x3D;100M count&#x3D;100,然后格式化并激活</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Linux/"># Linux</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/03/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/">第八章、文件与文件系统的压缩与打包</a>
            
            
            <a class="next" rel="next" href="/2022/03/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/">第六章、Linux文件与目录管理</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>We r dreamers</span>
    </div>
</footer>

    </div>
</body>

</html>